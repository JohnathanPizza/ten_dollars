; EXEC FILE FORMAT:
; byte 254 sec 19: code pages
; byte 255 sec 19: adjust pages
; sec 1: program code
; sec after last prog code: adjustment pointers

; adjust page ex:
; with 127 ptrs (max)
; 0-253: XXXX
; 254-255: 0000
; with N ptrs
; [0,2N-1]: XXXX
; [2N,2N+1]: 0000

>SERVICE_INIT_DISK
	LDY	PROC_ACTIVE_ID		; load proc id
	LDA.Y	PROC_A			; load file id from A
	DEC
	LSR
	LSR
	LSR
	LSR
	INC
	INC
	STA.Z	VR4 1
	STZ.Z	VR4
	JSR	RETRY_FLOPPY_READ
	CMP.I	0
	BEQ	_SERVICE_INIT_DISK_NAME
	JMP	_SERVICE_INIT_DISK_FAIL	; else fail
>_SERVICE_INIT_DISK_NAME
	LDA.Y	PROC_A
	DEC
	ASL
	ASL
	ASL
	ASL
	STA.Z	VR0
	LDA.I	FLOPPY_PAGE > 8
	STA.Z	VR0 1
	TYA
	ASL
	ASL
	ASL
	ASL
	STA.Z	VR1
	LDA.I	PROC_NAME > 8
	ADC.I	0			; 5th bit in carry for 0-15 and 16-31
	STA.Z	VR1 1
	LDA.I	16
	STA.Z	VR4
	JSR	STRNCPY

	LDA.Y	PROC_A			; load file id from A
	STA.Z	VR4			; set file track
	LDA.I	19			; load 19 for sector
	STA.Z	VR4 1			; set last sector of file
	JSR	RETRY_FLOPPY_READ	; read sector
	CMP.I	0			; test if succeeded
	BEQ	_SERVICE_INIT_DISK_CONT1	; continue if success
	JMP	_SERVICE_INIT_DISK_FAIL	; else fail
>_SERVICE_INIT_DISK_CONT1
	LDA	FLOPPY_PAGE 255		; get adjust pages count
	STA.Z	VR5			; save for later
	CLC				; clc for adc
	LDA	FLOPPY_PAGE 254		; load number of code pages
	ADC.I	2			; add 2 to get number of pages total needed
	STA.Z	VR7			; store in VR7/1
	JSR	PAGE_TABLE_VACANT	; get num of vacant pages
	CMP.Z	VR7			; compare to amount needed
	BGE	_SERVICE_INIT_DISK_CONT2	; continue if good
	JMP	_SERVICE_INIT_DISK_PAGES	; else fail
>_SERVICE_INIT_DISK_CONT2
	; get data pages
	JSR	PAGE_TABLE_GET		; get a vacant page
	TAY				; move page id to Y
	LDA	PROC_ACTIVE_ID		; load proc id
	STA.Y	PAGE_TABLE_PROCID	; store proc id in page row
	LDA.I	0X80			; load home value for ZP
	STA.Y	PAGE_TABLE_HOME		; store in page row
	PHY				; save page id
	JSR	PAGE_MAP_GET_BACK	; get empty map idx from back
	TAY				; move to Y
	PLA				; pull page id
	STA.Y	PAGE_MAP		; store page id in map at idx
	
	JSR	PAGE_TABLE_GET		; get a vacant page
	TAY				; move page id to Y
	LDA	PROC_ACTIVE_ID		; load proc id
	STA.Y	PAGE_TABLE_PROCID	; store proc id in page row
	LDA.I	0X81			; load home value for stack
	STA.Y	PAGE_TABLE_HOME		; store in page row
	PHY				; save page id
	JSR	PAGE_MAP_GET_BACK	; get empty map idx from back
	TAY				; move to Y
	PLA				; pull page id
	STA.Y	PAGE_MAP		; store page id in map at idx
	
	DEC.Z	VR7			; needed - 1
	DEC.Z	VR7			; needed - 2 because zp and stack pages claimed
	
	; get code pages
	LDA.Z	VR7			; load needed code pages count
	PHA				; push
	JSR	PAGE_MAP_LARGEST	; find map idx where the code pages should go
	STA.Z	VR7 1			; store starting map idx at VR7/2
	PHA				; push starting map idx
>_SERVICE_INIT_DISK_LOOP
	LDX.Z	VR7 1			; load next map idx to X
	LDA.X	PAGE_MAP		; load value of map idx there
	CMP.I	0XFF			; test if that map idx is empty
	BEQ	_SERVICE_INIT_DISK_LOOP_SKIP	; skip swap if already empty
	JSR	PAGE_MAP_GET_BACK	; get an empty map idx starting at the back
	TAY				; move map idx to Y
	JSR	PAGE_MAP_SWAP		; swap empty map idx at back with current map idx
>_SERVICE_INIT_DISK_LOOP_SKIP
	JSR	PAGE_TABLE_GET		; get empty page table row
	TAY				; move page id to Y
	LDA	PROC_ACTIVE_ID		; load proc id
	STA.Y	PAGE_TABLE_PROCID	; store proc id in page row
	LDA.Z	VR7 1			; load current map idx
	STA.Y	PAGE_TABLE_HOME		; store in home value
	TYA				; move page id to A
	LDY.Z	VR7 1			; load map idx in Y
	STA.Y	PAGE_MAP		; store page id in map idx
	INC.Z	VR7 1			; inc map idx to go to next one
	DEC.Z	VR7			; dec the number of needed pages
	BNE	_SERVICE_INIT_DISK_LOOP	; loop if needed page count is not 0

	; copy code into pages
	PLA				; pull starting map idx from earlier
	CLC				; clc for adc
	ADC.I	PAGE_MAP_RAM_BASE	; load page of start of code pages for pagecpy
	STA.Z	VR1 1
	LDA.I	FLOPPY_PAGE > 8		; load page of floppy page for pagecpy
	STA.Z	VR0 1
	LDX	PROC_ACTIVE_ID		; load proc id
	LDA.X	PROC_A			; get file id again
	STA.Z	VR4			; set file track
	PLA				; get number of code pages
	STA.Z	VR7			; store again
	LDA.Z	VR1 1			; load first page idx
	STA.Z	VR6			; save again for adjust
	LDA.I	1			; load 1 for sector
	STA.Z	VR4 1			; set start sector to 1
>_SERVICE_INIT_DISK_CODE_LOOP
	JSR	RETRY_FLOPPY_READ	; read sector
	CMP.I	0			; test if success
	BNE	_SERVICE_INIT_DISK_FAIL	; fail if not
	JSR	PAGECPY			; copy sector to code page
	INC.Z	VR1 1			; inc code page
	INC.Z	VR4 1			; inc sector
	DEC.Z	VR7			; dec number of pages left
	BNE	_SERVICE_INIT_DISK_CODE_LOOP	; loop if not done

	; adjust
	; vr4 still has track and vr4 1 has first adjust sector
	LDA.Z	VR6			; get first page idx
	STA.Z	VR0 1			; set pointer to code in VR0
	STZ.Z	VR0
	LDA.I	FLOPPY_PAGE > 8		; get floppy page idx
	STA.Z	VR1 1			; store as pointer to adjustments in vr1
	STZ.Z	VR1
	LDA.Z	VR4			; save track
	STA.Z	VR6
	LDA.Z	VR4 1			; save sector
	STA.Z	VR6 1
>_SERVICE_INIT_DISK_ADJUST_LOOP
	LDA.Z	VR6			; load track
	STA.Z	VR4
	LDA.Z	VR6 1			; load sector
	STA.Z	VR4 1
	JSR	RETRY_FLOPPY_READ	; read sector
	CMP.I	0			; test if success
	BNE	_SERVICE_INIT_DISK_FAIL	; fail if not
	STZ.Z	VR4			; set adjust offset to 0
	STZ.Z	VR4 1
	JSR	PROGRAM_ADJUST		; adjust
	INC.Z	VR6 1			; inc sector
	DEC.Z	VR5			; dec number of adj pages
	BNE	_SERVICE_INIT_DISK_ADJUST_LOOP	; loop if not done

	; set vars
	LDA	PROC_ACTIVE_ID		; load proc id
	ASL				; *2 for offset
	TAY				; set in Y
	LDA.Z	VR0 1			; load code location
	STA.Y	PROC_PTROFF 1		; set ptroff
	LDA.I	0
	STA.Y	PROC_PTROFF
	LDA.Z	VR0 1			; set PC to code
	STA.Y	PROC_PC 1
	LDA.I	0
	STA.Y	PROC_PC
	LDY	PROC_ACTIVE_ID		; load proc active id
	LDA.I	0XFF			; load initial value for stack pointer
	STA.Y	PROC_S			; set stack
	LDA.I	0B00100000		; load initial value for processor flags
	STA.Y	PROC_P			; set flags
	LDA.I	2			; load initial value for priortiy
	STA.Y	PROC_SCHEDULE_PRIORITY	; set priority
	LDA.I	PROC_STATE_READY	; load ready state
	STA.Y	PROC_STATE		; update state
	LDA.I	0X80			; load initial value for no DAP
	STA.Y	PROC_ACTIVE_DAP_ID	; store in DAP
	JMP	SERVICE_CYCLE_BEGIN	; start new cycle
>_SERVICE_INIT_DISK_FAIL
	LDA.I	PROC_STATE_EXIT
	LDY	PROC_ACTIVE_ID
	STA.Y	PROC_STATE
>_SERVICE_INIT_DISK_PAGES
	JMP	SERVICE_CYCLE_BEGIN
