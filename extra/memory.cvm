; MEMORY.CVM
; ===
; MEMSET
; MEMCPY
; PAGESET
; PAGECPY
; PAGESWAP

;=========================================

; MEMSET
; P --- VR0: pointer to memory P
;	VR4: length of memory L
;	VR5/1: value V
; sets the first L bytes at P to V

>MEMSET
	PHA		; store A
	PHX		; store X
	
	LDA.Z	VR0	; copy P to VR8
	STA.Z	VR8
	LDA.Z	VR0 1
	STA.Z	VR8 1

	LDA.Z	VR4	; copy L to VR9
	STA.Z	VR9
	LDA.Z	VR4 1
	STA.Z	VR9 1
	BRA	_MEMSET_LOOP_CHECK
>_MEMSET_LOOP
	LDA.Z	VR5	; load V
	STA.ZP	VR8	; set next byte at P to V
	JSR	INC8	; increment P
	JSR	DEC9	; decrement L
>_MEMSET_LOOP_CHECK
	LDA.Z	VR9	; test if L is 0
	ORA.Z	VR9 1
	BNE	_MEMSET_LOOP	; if not 0 loop again
>_MEMSET_LOOP_END
	PLX		; restore X
	PLA		; restore A
	RTS		; return

;==================================================

; MEMCPY
; P --- VR0: pointer to source memory S
;	VR1: pointer to destination memory D
;	VR4: length of source memory L
; copies the first L bytes from S to D

>MEMCPY
	PHA		; store A
	PHX		; store X
	
	LDA.Z	VR0	; copy S to VR8
	STA.Z	VR8
	LDA.Z	VR0 1
	STA.Z	VR8 1

	LDA.Z	VR1	; copy D to VR9
	STA.Z	VR9
	LDA.Z	VR1 1
	STA.Z	VR9 1

	LDA.Z	VR4	; copy L to VR10
	STA.Z	VR10
	LDA.Z	VR4 1
	STA.Z	VR10 1
	BRA	_MEMCPY_LOOP_CHECK
>_MEMCPY_LOOP
	LDA.ZP	VR8	; load next byte from S
	STA.ZP	VR9	; store at next byte in D
	JSR	INC8	; increment S
	JSR	INC9	; increment D
	JSR	DEC10	; decrement L
>_MEMCPY_LOOP_CHECK
	LDA.Z	VR10	; test if L is 0
	ORA.Z	VR10 1
	BNE	_MEMSET_LOOP	; if not 0 loop again
>_MEMCPY_LOOP_END
	PLX		; restore X
	PLA		; restore A
	RTS		; return

;==================================================

; PAGESET
; P --- VR0/2: page number P
;	VR5/1: value V
; sets every byte in page P to V

>PAGESET
	PHA		; store A
	
	LDA.Z	VR0	; save VR0/1 to stack
	PHA
	LDA.Z	VR4	; save VR4 to stack
	PHA
	LDA.Z	VR4 1
	PHA

	STZ.Z	VR0	; set memset ptr to address of first byte in page P
	STZ.Z	VR4	; set memset len to 0x100
	LDA.I	1
	STA.Z	VR4 1
	JSR	MEMSET	; call memset

	PLA		; restore VR4 from stack
	STA.Z	VR4 1
	PLA
	STA.Z	VR4
	PLA		; restore VR0/1 from stack
	STA.Z	VR0
	PLA		; restore A
	RTS		; return

;==================================================

; PAGECPY
; P --- VR0/2: source page number S
;	VR1/2: destination page number D
; copies every byte in page S to page D

>PAGECPY
	PHA		; store A
	
	LDA.Z	VR0	; save VR0/1 to stack
	PHA
	LDA.Z	VR1	; save VR1/1 to stack
	PHA
	LDA.Z	VR4	; save VR4 to stack
	PHA
	LDA.Z	VR4 1
	PHA

	STZ.Z	VR0	; set memcpy source ptr to first byte of page S
	STZ.Z	VR1	; set memcpy destination ptr to first byte of page D
	STZ.Z	VR4	; set memcpy length to 0x100
	LDA.I	1
	STA.Z	VR4 1
	JSR	MEMCPY	; call memcpy

	PLA		; restore VR4 from stack
	STA.Z	VR4 1
	PLA
	STA.Z	VR4
	PLA		; restore VR1/1 from stack
	STA.Z	VR1
	PLA		; restore VR0/1 from stack
	STA.Z	VR0
	PLA		; restore A
	RTS		; return

;==================================================

; PAGESWAP
; P --- VR4/1: page 1 number A
;	VR4/2: page 2 number B
; swaps the value of every byte in pages A and B

>PAGESWAP
	PHA		; store A
	PHX		; store X
	PHY		; store Y

	LDA.Z	VR4	; create page A pointer in VR8
	STA.Z	VR8 1
	STZ.Z	VR8
	LDA.Z	VR4 1	; create page B pointer in VR9
	STA.Z	VR9 1
	STZ.Z	VR9

	LDX.I	0	; set index counter to 0
>_PAGESWAP_LOOP
	LDA.ZP	VR8	; load from page A
	TAY		; put in Y
	LDA.ZP	VR9	; load from page B
	STA.ZP	VR8	; store page B byte to page A
	TYA		; get from Y
	STA.ZP	VR9	; store page A byte to page B

	JSR	INC8	; increment A pointer
	JSR	INC9	; increment B pointer
	INX		; increment index
	BNE	_PAGESWAP_LOOP	; if index not 0 then loop

	PLY		; restore Y
	PLX		; restore X
	PLA		; restore A
	RTS		; return
