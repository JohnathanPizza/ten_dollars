; PRINT.CVM
; ===
; PRINTS
; PRINTC
; PRINTB
; PRINTL

;==================================================

; PRINTS
; P --- VR0: string pointer S
; calls the write BRK function to write out S over IO
; must be null character delimited

>PRINTS
	PHA			; store A
	PHX
	PHY
	
	LDA.Z	VR4		; copy out VR4/1
	PHA
	LDA.Z	VR7		; copy out VR7/1
	PHA
	LDA.Z	VR0		; copy out VR0
	PHA
	LDA.Z	VR0 1
	PHA

	JSR	STRLEN		; get string length
	STA.Z	VR7		; copy strlen result into VR7
	LDA.I	BC_WRITES	; load write string BRK code
	STA.Z	VR4		; store in VR4
>_PRINTS_LOOP
	BRK			; call write BRK
	LDA.Z	VR7
	CMP.Z	VR11
	BEQ	_PRINTS_LOOP_END
	SEC
	SBC.Z	VR11
	STA.Z	VR7
	LDA.Z	VR0
	CLC
	ADC.Z	VR7
	STA.Z	VR0
	LDA.Z	VR0 1
	ADC.I	0
	STA.Z	VR0 1
	BRA	_PRINTS_LOOP
>_PRINTS_LOOP_END
	PLA
	STA.Z	VR0 1
	PLA
	STA.Z	VR0
	PLA
	STA.Z	VR7
	PLA
	STA.Z	VR4		; copy back VR4/1

	PLY
	PLX
	PLA			; restore A
	RTS			; return

;==================================================

; PRINTC
; P --- A: character C
; writes C to IO

>PRINTC
	STA.Z	VR8		; store C in VR8
	LDA.Z	VR5		; copy out VR5
	PHA
	LDA.Z	VR4		; copy out VR4/1
	PHA
	LDA.Z	VR8
	STA.Z	VR5
	LDA.I	BC_WRITEC
	STA.Z	VR4
>_PRINTC_LOOP
	BRK
	LDA.Z	VR11
	BEQ	_PRINTC_LOOP
	LDA.Z	VR5
	STA.Z	VR8
	PLA
	STA.Z	VR4
	PLA
	STA.Z	VR5
	LDA.Z	VR8		; restore C in A
	RTS			; return

;==================================================

; PRINTB
; P --- A: byte B
; writes the hexadecimal representation of B to IO

>PRINTB
	PHA		; store A
	ROR		; shift high nybble into low nybble
	ROR
	ROR
	ROR
	JSR	TOHEX	; get hex character for high nybble
	JSR	PRINTC	; print it
	PLA		; reload A
	PHA		; store A
	JSR	TOHEX	; get hex character for low nybble
	JSR	PRINTC	; print it
	PLA		; restore B
	RTS		; return

;==================================================

; PRINTL
; writes the newline character

>PRINTL
	PHA		; store A
	LDA.I	ASCII_LF	; load newline
	JSR	PRINTC	; print newline
	PLA		; restore A
	RTS		; return
