; STRING.CVM
; ===
; STRLEN
; STRNLEN
; STRCPY
; STRNCPY
; STRCMP
; STRNCMP
; STRCHR
; STRRCHR
; STRCAT
; STRNCAT
; STRTONUM

; string functions operate under the assumption that no string will have a length of more than 254

;==================================================

; STRLEN
; P --- VR0: string pointer S
; R --- A: string length L
; if L = 255, then 255 bytes were read that were not the nul character, actual string length is unknown

>STRLEN
	LDA.Z	VR0		; copy S to VR8
	STA.Z	VR8
	LDA.Z	VR0 1
	STA.Z	VR8 1
	STZ.Z	VR9		; set temp counter for L to 0
>_STRLEN_LOOP
	LDA.ZP	VR8		; load next character from S
	BEQ	_STRLEN_END	; exit if nul char
	JSR	INC8		; inc S
	INC.Z	VR9		; inc L
	LDA.I	0XFF		; load max value
	CMP.Z	VR9		; compare L to max value
	BNE	_STRLEN_LOOP	; if not max value then loop
>_STRLEN_END
	LDA.Z	VR9		; load L to A
	RTS			; return

;==================================================

; STRNLEN
; P --- VR0: string pointer S
;	VR4/1: number to check N
; R --- A: string length L
; calculates the length of the string at S which is delimited by the null character
; checks the first N characters of the string
; L = N if the string contains more than N non-null characters
; if N is greater than or equal to the number of non-null characters, this function behaves just like STRLEN

>STRNLEN
	LDA.Z	VR0		; copy S into VR8
	STA.Z	VR8
	LDA.Z	VR0 1
	STA.Z	VR8 1
	LDA.Z	VR4		; copy N into VR9/1
	STA.Z	VR9
	STZ.Z	VR10		; set temp counter for L to 0

	BRA	_STRNLEN_LOOP_CHECK	; enter loop
>_STRNLEN_LOOP
	LDA.ZP	VR8		; get next character from S
	BEQ	_STRNLEN_END	; if 0 then stop counting and return
	JSR	INC8		; inc S
	DEC.Z	VR9		; dec N
	INC.Z	VR10		; inc L
	LDA.I	0XFF		; load max value
	CMP.Z	VR10		; compare L to max value
	BEQ	_STRNLEN_END	; if max value then exit
>_STRNLEN_LOOP_CHECK
	LDA.Z	VR9		; test if N is 0
	BNE	_STRNLEN_LOOP	; loop if not 0
>_STRNLEN_END
	LDA.Z	VR10		; load L to A
	RTS			; return

;==================================================

; STRCPY
; P ---	VR0: existing string pointer S
;	VR1: destination pointer D
; copies string S to D, stopping after the delimiting nul character is copied

>STRCPY
	PHA			; store A
	LDA.Z	VR0		; copy S to VR8
	STA.Z	VR8
	LDA.Z	VR0 1
	STA.Z	VR8 1
	LDA.Z	VR1		; copy D to VR9
	STA.Z	VR9
	LDA.Z	VR1 1
	STA.Z	VR9 1
>_STRCPY_LOOP
	LDA.ZP	VR8		; load next character from the string
	STA.ZP	VR9		; store at next location at the destination
	BEQ	_STRCPY_END	; if it was the null character, return
	JSR	INC8		; inc S
	JSR	INC9		; inc D
	BRA	_STRCPY_LOOP	; loop
>_STRCPY_END
	PLA			; restore A
	RTS			; return

;==================================================

; STRNCPY
; P --- VR0: existing string pointer S
;	VR1: destination pointer D
;	VR4/1: number to copy N
; copies string S to D, stopping after the delimiting nul character is copied or N characters have been copied
; if N characters are copied before the nul character is copied, no nul character is appended at the destination by this function

>STRNCPY
	PHA			; store A
	LDA.Z	VR0		; copy S to VR8
	STA.Z	VR8
	LDA.Z	VR0 1
	STA.Z	VR8 1
	LDA.Z	VR1		; copy D to VR9
	STA.Z	VR9
	LDA.Z	VR1 1
	STA.Z	VR9 1
	LDA.Z	VR4		; copy N to VR10/1
	STA.Z	VR10

	BRA	_STRNCPY_LOOP_CHECK	; enter loop
>_STRNCPY_LOOP
	LDA.ZP	VR8		; load next character from S
	STA.ZP	VR9		; store into next spot in D
	BEQ	_STRNCPY_END	; exit if nul character was copied
	JSR	INC8		; inc S
	JSR	INC9		; inc D
	DEC.Z	VR10		; dec N
>_STRNCPY_LOOP_CHECK
	LDA.Z	VR10		; test if N is 0
	BNE	_STRNCPY_LOOP	; if not 0 then loop
>_STRNCPY_END
	PLA			; restore A
	RTS			; return

;==================================================

; STRCMP
; P --- VR0: pointer to first string A
;	VR1: pointer to second string B
; R --- A: comparison value V
; returns the difference of the first unequal characters at equal indicies from A and B
; stops comparing after the first nul character is found in either string
; if V = 0 then the strings are equal up to the first nul character
; otherwise the strings are not equal at some point

>STRCMP
	LDA.Z	VR0		; copy A to VR8
	STA.Z	VR8
	LDA.Z	VR0 1
	STA.Z	VR8 1
	LDA.Z	VR1		; copy B to VR9
	STA.Z	VR9
	LDA.Z	VR1 1
	STA.Z	VR9 1
>_STRCMP_LOOP
	LDA.ZP	VR8		; load character from A
	SEC			; sec for sbc
	SBC.ZP	VR9		; subtract value from character in B
	BNE	_STRCMP_END	; if values not equal, return
	LDA.ZP	VR8		; load value from A
	BEQ	_STRCMP_END	; if nul char, return
	JSR	INC8		; inc A
	JSR	INC9		; inc B
	BRA	_STRCMP_LOOP	; loop
>_STRCMP_END
	RTS			; return

;==================================================

; STRNCMP
; P --- VR0: pointer to first string A
;	VR1: pointer to second string B
;	VR4/1: number to compare N
; R --- A: comparison value V
; returns the difference of the first unequal characters at equal indicies from A and B
; stops comparing after the first nul character is found in either string or when N characters are compared
; if V = 0 then the strings are equal up to the first nul character or N characters
; otherwise the strings are not equal at some point

>STRNCMP
	LDA.Z	VR0		; copy A to VR8
	STA.Z	VR8
	LDA.Z	VR0 1
	STA.Z	VR8 1
	LDA.Z	VR1		; copy B to VR9
	STA.Z	VR9
	LDA.Z	VR1 1
	STA.Z	VR9 1
	LDA.Z	VR4		; copy N to VR10/1
	STA.Z	VR10

	BRA	_STRNCMP_LOOP_CHECK
>_STRNCMP_LOOP
	LDA.ZP	VR8		; load character from A
	SEC			; sec for sbc
	SBC.ZP	VR9		; subtract value from character in B
	BNE	_STRNCMP_END	; if values not equal, return
	LDA.ZP	VR8		; load value from A
	BEQ	_STRNCMP_END	; if nul char, return
	JSR	INC8		; inc A
	JSR	INC9		; inc B
	DEC.Z	VR10		; dec N
>_STRNCMP_LOOP_CHECK
	LDA.Z	VR10		; test if N is 0
	BNE	_STRNCMP_LOOP	; loop
>_STRNCMP_END
	RTS			; return

;==================================================

; STRCHR
; P --- VR0: string pointer S
;	A: character C
; R --- A: character index I
; returns the index I of the first occurance of C in string S
; if I = 255 then the character was not found in the string

>STRCHR
	PHX			; store X
	LDX.I	0		; set I to 0
	STA.Z	VR8		; store C in VR8/1
	LDA.Z	VR0		; copy S to VR9
	STA.Z	VR9
	LDA.Z	VR0 1
	STA.Z	VR9 1
>_STRCHR_LOOP
	LDA.ZP	VR9		; load character from S
	CMP.Z	VR8		; compare to C
	BEQ	_STRCHR_END	; if equal, return at I
	LDA.ZP	VR9		; load character from S again
	BEQ	_STRCHR_FAIL	; if nul char, return failure
	INX			; inc I
	CPX.I	0XFF		; compare I to max value 0xFF
	BNE	_STRCHR_LOOP	; if not max, loop
>_STRCHR_FAIL
	LDX.I	0XFF		; set I to 0xFF max value
>_STRCHR_END
	TXA			; move I to A
	PLX			; restore X
	RTS			; return

;==================================================

; STRRCHR
; P --- VR0: string pointer S
;	A: character C
; R --- A: character index I
; returns the index I of the last occurance of C in string S
; if I = 255 then the character was not found in the string

>STRRCHR
	PHX			; store X
	LDX.I	0		; set index to 0
	STA.Z	VR8		; store C in VR8/1
	LDA.Z	VR0		; copy S to VR9
	STA.Z	VR9
	LDA.Z	VR0 1
	STA.Z	VR9 1
	LDA.I	0XFF		; load max value
	STA.Z	VR10		; store in VR10/1 to track most recent index of C
>_STRRCHR_LOOP
	LDA.ZP	VR9		; load character from S
	CMP.Z	VR8		; compare to C
	BNE	_STRRCHR_LOOP_CONT	; if not equal, keep scanning
	STX.Z	VR10		; C is at this index, update most recent
>_STRRCHR_LOOP_CONT
	LDA.ZP	VR9		; load character from S again
	BEQ	_STRRCHR_END	; if nul char, return
	INX			; inc index
	CPX.I	0XFF		; compare index to max value 0xFF
	BNE	_STRRCHR_LOOP	; if not max, loop
>_STRRCHR_END
	LDA.Z	VR10		; load I to A
	PLX			; restore X
	RTS			; return

;==================================================

; STRCAT
; P --- VR0: base string B
;	VR1: appending string C
; copies the characters in C to the very end of B to concatenate the two strings
; starts at the nul character in B and also copies the nul character from C

>STRCAT
	PHA			; store A
	LDA.Z	VR0		; copy B to VR8
	STA.Z	VR8
	LDA.Z	VR0 1
	STA.Z	VR8 1
	LDA.Z	VR1		; copy C to VR9
	STA.Z	VR9
	LDA.Z	VR1 1
	STA.Z	VR9 1
>_STRCAT_LOOP1
	LDA.ZP	VR8		; load character from B
	BEQ	_STRCAT_LOOP2	; if nul char, go to the next loop
	JSR	INC8		; inc B
	BRA	_STRCAT_LOOP1	; loop
>_STRCAT_LOOP2
	LDA.ZP	VR9		; load character from C
	STA.ZP	VR8		; store in B
	BEQ	_STRCAT_END	; if nul char was stored, end
	JSR	INC8		; inc B
	JSR	INC9		; inc C
	BRA	_STRCAT_LOOP2	; loop
>_STRCAT_END
	PLA			; restore A
	RTS			; return

;==================================================

; STRNCAT
; P --- VR0: base string B
;	VR1: appending string C
;	VR4/1: number to copy N
; copies the characters in C to the very end of B to concatenate the two strings
; starts at the nul character in B and also copies the nul character from C
; stops after copying N characters or reaching the end of string C
; if N is less than or equal to the length of C then the nul character is not copied

>STRNCAT
	PHA			; store A
	LDA.Z	VR0		; copy B to VR8
	STA.Z	VR8
	LDA.Z	VR0 1
	STA.Z	VR8 1
	LDA.Z	VR1		; copy C to VR9
	STA.Z	VR9
	LDA.Z	VR1 1
	STA.Z	VR9 1
	LDA.Z	VR4		; copy N to VR10/1
	STA.Z	VR10
>_STRNCAT_LOOP1
	LDA.ZP	VR8		; load character from B
	BEQ	_STRNCAT_LOOP2_CHECK	; if nul char, go to the next loop
	JSR	INC8		; inc B
	BRA	_STRNCAT_LOOP1	; loop
>_STRNCAT_LOOP2
	LDA.ZP	VR9		; load character from C
	STA.ZP	VR8		; store in B
	BEQ	_STRNCAT_END	; if nul char was stored, end
	JSR	INC8		; inc B
	JSR	INC9		; inc C
	DEC.Z	VR10		; dec N
>_STRNCAT_LOOP2_CHECK
	LDA.Z	VR10		; test if N is 0
	BNE	_STRNCAT_LOOP2	; if not 0 loop
>_STRNCAT_END
	PLA			; restore A
	RTS			; return

;==================================================

; STRTONUM
; P --- VR0: pointer to string S
; R --- VR11: 16-bit number N
;	A: success value V
; converts the numbers in S to a 16-bit integer N
; if whitespace at the beggining of S is skipped
; if the first non-whitespace character of S is '-' then N is converted into a signed negative number
; the number in S can be in binary, hexadecimal, or decimal format
; V = TRUE when S was successfully turned into a number
; V = FALSE when an error occurred

>STRTONUM
	STZ.Z	VR9		; set negative var to 0
	STZ.Z	VR11		; set N to 0
	STZ.Z	VR11 1
	LDA.Z	VR0		; move S to VR4
	STA.Z	VR4
	LDA.Z	VR0 1
	STA.Z	VR4 1
>_STRTONUM_WS
	LDA.ZP	VR4		; load character from S
	JSR	ISSPACE		; test if character is whitespace
	CMP.I	FALSE		; test if not whitespace
	BEQ	_STRTONUM_CHAR	; exit loop if not
	JSR	INC4		; increment S pointer
	BRA	_STRTONUM_WS	; loop if character was whitespace
>_STRTONUM_CHAR
	LDA.ZP	VR4
	CMP.I	ASCII_HYPHEN	; test if number begins with hyphen
	BNE	_STRTONUM_POS	; skip if not hyphen
	INC.Z	VR9		; increment negative var to 1
	JSR	INC4		; increment S pointer
	LDA.ZP	VR4		; load next character
>_STRTONUM_POS
	JSR	TOUPPER		; make char uppercase
	CMP.I	ASCII_X		; test if X for hex base
	BEQ	_STRTONUM_HEX	; go to hex code if hex
	CMP.I	ASCII_B		; test if B for binary base
	BNE	_STRTONUM_DEC	; go to decimal code if not binary
	JMP	_STRTONUM_BIN	; else go to binary code
>_STRTONUM_DEC
	LDA.ZP	VR4		; load character
	BNE	_STRTONUM_DEC_NOTNUL	; if not nul char then continue
	JMP	_STRTONUM_FINISH	; else finish
>_STRTONUM_DEC_NOTNUL
	JSR	ISSPACE		; test if space
	CMP.I	TRUE		; if is space char
	BNE	_STRTONUM_DEC_NOTSPACE	; if not space then continue
	JMP	_STRTONUM_FINISH	; else finish
>_STRTONUM_DEC_NOTSPACE
	LDA.ZP	VR4		; load char again
	JSR	ISNUM		; test if number char
	CMP.I	TRUE		; if number char
	BEQ	_STRTONUM_DEC_NOTFAIL	; then continue
	JMP	_STRTONUM_FAIL	; else fail
>_STRTONUM_DEC_NOTFAIL
	ASL.Z	VR11		; N = N * 2
	ROL.Z	VR11 1
	LDA.Z	VR11		; copy N * 2 to VR10
	STA.Z	VR10
	LDA.Z	VR11 1
	STA.Z	VR10 1
	PHX			; store X
	PHY			; store Y
	LDX.I	VRI_11		; load VR11 index
	LDY.I	VRI_10		; load VR10 index
	JSR	ADD16		; N = N * 2 + N * 2 = N * 4
	JSR	ADD16		; N = N * 2 + N * 2 + N * 2 = N * 6
	JSR	ADD16		; N = N * 2 + N * 2 + N * 2 + N * 2 = N * 8
	JSR	ADD16		; N = N * 2 + N * 2 + N * 2 + N * 2 + N * 2 = N * 10
	PLY			; restore Y
	PLX			; restore X
	LDA.ZP	VR4		; load char again
	SEC			; sec for sbc
	SBC.I	ASCII_0		; convert ascii value to number value
	CLC			; clc for adc
	ADC.Z	VR11		; add number value to N
	STA.Z	VR11
	LDA.Z	VR11 1
	ADC.I	0
	STA.Z	VR11 1
	JSR	INC4		; increment S pointer
	BRA	_STRTONUM_DEC	; loop
>_STRTONUM_HEX
	JSR	INC4		; increment S pointer
	LDA.ZP	VR4		; load character
	BEQ	_STRTONUM_FINISH	; if nul char then finish
	JSR	ISSPACE		; test if space
	CMP.I	TRUE		; if is space char
	BEQ	_STRTONUM_FINISH	; then finish
	LDA.ZP	VR4		; load char again
	JSR	ISHEX		; test if hex char
	CMP.I	TRUE		; if  hex char
	BEQ	_STRTONUM_HEX_NOTFAIL	; then continue
	JMP	_STRTONUM_FAIL	; else fail
>_STRTONUM_HEX_NOTFAIL
	LDA.ZP	VR4		; load char again
	JSR	ISNUM		; test if number char
	CMP.I	TRUE		; if number char
	BEQ	_STRTONUM_HEX_DIGIT	; go to decimal handling
	LDA.ZP	VR4		; load char again
	JSR	TOUPPER		; make uppercase
	SEC			; sec for sbc
	SBC.I	ASCII_A		; convert ascii value to number value - 10
	CLC			; clc for adc
	ADC.I	10		; add 10 to make correct number value
	ASL.Z	VR11		; N = N * 16
	ROL.Z	VR11 1
	ASL.Z	VR11
	ROL.Z	VR11 1
	ASL.Z	VR11
	ROL.Z	VR11 1
	ASL.Z	VR11
	ROL.Z	VR11 1
	ORA.Z	VR11		; add number to N
	STA.Z	VR11
	BRA	_STRTONUM_HEX	; loop
>_STRTONUM_HEX_DIGIT
	LDA.ZP	VR4		; load char
	SEC			; sec for sbc
	SBC.I	ASCII_0		; convert ascii value to number value
	ASL.Z	VR11		; N = N * 16
	ROL.Z	VR11 1
	ASL.Z	VR11
	ROL.Z	VR11 1
	ASL.Z	VR11
	ROL.Z	VR11 1
	ASL.Z	VR11
	ROL.Z	VR11 1
	ORA.Z	VR11		; add number value to N
	STA.Z	VR11
	BRA	_STRTONUM_HEX	; loop
>_STRTONUM_BIN
	JSR	INC4		; increment S pointer
	LDA.ZP	VR4		; load character
	BEQ	_STRTONUM_FINISH	; if nul char then finish
	JSR	ISSPACE		; test if space
	CMP.I	TRUE		; if is space char
	BEQ	_STRTONUM_FINISH	; then finish
	LDA.ZP	VR4		; load char again
	CMP.I	ASCII_0		; test if 0
	BEQ	_STRTONUM_BIN_0	; go to 0 code if so
	CMP.I	ASCII_1		; test if 1
	BEQ	_STRTONUM_BIN_1	; go to 1 code if so
	BRA	_STRTONUM_FAIL	; otherwise fail
>_STRTONUM_BIN_0
	ASL.Z	VR11		; N = N * 2
	ROL.Z	VR11 1
	BRA	_STRTONUM_BIN	; loop
>_STRTONUM_BIN_1
	SEC			; N = N * 2 + 1
	ROL.Z	VR11
	ROL.Z	VR11 1
	BRA	_STRTONUM_BIN	; loop
>_STRTONUM_FINISH
	LDA.Z	VR9		; load negative var
	BEQ	_STRTONUM_FINFIN	; skip negative conversion if not set
	CLC			; clc for adc
	LDA.Z	VR11		; load low byte
	EOR.I	0XFF		; invert
	ADC.I	1		; add 1
	STA.Z	VR11		; store back
	LDA.Z	VR11 1		; load high byte
	EOR.I	0XFF		; invert
	ADC.I	0		; add 0 + C
	STA.Z	VR11 1		; store back
>_STRTONUM_FINFIN
	LDA.I	TRUE		; load success value
	RTS			; return
>_STRTONUM_FAIL
	LDA.I	FALSE		; load fail value
	RTS			; return
