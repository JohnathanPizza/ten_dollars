; 01234567
; 1D1D1D1D

; data to encoded:
; 01234567
; ABCDEFGH
; >
; 0123456701234567
; 1A1C1E1G1B1D1F1H

; low A
;ASL
;ORA.I	0B01010101
; high A
;ORA.I	0B01010101
; decode
;LDA	LOW
;SEC
;ROR
;AND	HIGH

>FLOPPY_ENTER
	SEI				; interrupts must be off for WAI abuse
	STA	HW_ENABLE_ADDR HW_RAM1 HW_VIA	; enable VIA

	LDA	VIA_IER			; load existing values from IER
	STA.Z	VR7			; save to safe place
	LDA.I	0B01111111		; load value to turn off all of them
	STA	VIA_IER			; turn off all IER
	LDA.I	VIA_IER_ENABLE VIA_IB_CA2	; load value to turn on floppy interrupt
	STA	VIA_IER			; turn on

	LDA.I	0B00001111		; load initial values for control port
	STA	VIA_FLOPPY_CONTROL_PORT	; store
	LDA.I	0B10011111		; load IO direction values for control port
	STA	VIA_FLOPPY_CONTROL_DIR	; store
	; data port wont matter since it is already coming from an all input state

	LDA	VIA_PCR			; load PCR to toggle the floppy enable line
	ORA.I	0B00100000		; turn on enable line
	STA	VIA_PCR			; store back
	
	RTS				; return

>FLOPPY_EXIT
	LDA	VIA_PCR			; load PCR to turn off floppy enable line
	AND.I	0B11011111		; turn off
	STA	VIA_PCR			; store back
	
	STZ	VIA_READ_PORT_DIR	; store zero to keyboard port so it is all input
	STZ	VIA_WRITE_PORT		; set printer port output to zero
	LDA.I	0XFF			; load value to set printer port to all output
	STA	VIA_WRITE_PORT_DIR	; store
	
	LDA.I	VIA_IER_DISABLE VIA_IB_CA2	; load value to turn off floppy interrupt
	STA	VIA_IER			; turn off
	LDA.Z	VR7			; pull old IER
	STA	VIA_IER			; can just store back since bit 7 will be 1 which enables

	STA	HW_ENABLE_ADDR HW_RAM1	; turn off VIA now
	CLI				; turn interrupts back on

	RTS				; return

=FLOPPY_STEP_TIME 10

>FLOPPY_STEP_DOWN
	PHA
	LDA	VIA_FLOPPY_CONTROL_PORT
	ORA.I	0B00000001
	STA	VIA_FLOPPY_CONTROL_PORT
	LDA.I	FLOPPY_STEP_TIME
	JSR	WAIT_MILIS
	LDA	VIA_FLOPPY_CONTROL_PORT ; < bruh didnt have this
	AND.I	0B11111101
	STA	VIA_FLOPPY_CONTROL_PORT
	LDA.I	FLOPPY_STEP_TIME
	JSR	WAIT_MILIS
	LDA	VIA_FLOPPY_CONTROL_PORT
	ORA.I	0B00000010
	STA	VIA_FLOPPY_CONTROL_PORT
	LDA.I	FLOPPY_STEP_TIME
	JSR	WAIT_MILIS
	PLA
	RTS

>FLOPPY_STEP_UP
	PHA
	LDA	VIA_FLOPPY_CONTROL_PORT
	AND.I	0B11111110
	STA	VIA_FLOPPY_CONTROL_PORT
	LDA.I	FLOPPY_STEP_TIME
	JSR	WAIT_MILIS
	LDA	VIA_FLOPPY_CONTROL_PORT ; < bruh
	AND.I	0B11111101
	STA	VIA_FLOPPY_CONTROL_PORT
	LDA.I	FLOPPY_STEP_TIME
	JSR	WAIT_MILIS
	LDA	VIA_FLOPPY_CONTROL_PORT
	ORA.I	0B00000010
	STA	VIA_FLOPPY_CONTROL_PORT
	LDA.I	FLOPPY_STEP_TIME
	JSR	WAIT_MILIS
	PLA
	RTS

>FLOPPY_CALIBRATE_TRACK
	PHA
>_FLOPPY_CALIBRATE_LOOP
	LDA	VIA_FLOPPY_CONTROL_PORT
	AND.I	0B00100000
	BEQ	_FLOPPY_CALIBRATE_END
	JSR	FLOPPY_STEP_DOWN
	BRA	_FLOPPY_CALIBRATE_LOOP
>_FLOPPY_CALIBRATE_END
	STZ	FLOPPY_TRACK
	JSR	FLOPPY_SIDE_A
	PLA
	RTS

;A
>FLOPPY_SET_TRACK
	PHA
	PHX
	TAX
	CPX	FLOPPY_TRACK
	BEQ	_FLOPPY_SET_TRACK_END
	BLS	_FLOPPY_SET_TRACK_LOOP_DOWN
>_FLOPPY_SET_TRACK_LOOP_UP
	JSR	FLOPPY_STEP_UP
	INC	FLOPPY_TRACK
	CPX	FLOPPY_TRACK
	BNE	_FLOPPY_SET_TRACK_LOOP_UP
	BRA	_FLOPPY_SET_TRACK_END
>_FLOPPY_SET_TRACK_LOOP_DOWN
	JSR	FLOPPY_STEP_DOWN
	DEC	FLOPPY_TRACK
	CPX	FLOPPY_TRACK
	BNE	_FLOPPY_SET_TRACK_LOOP_DOWN
>_FLOPPY_SET_TRACK_END
	PLX
	PLA
	RTS

>FLOPPY_SIDE_A
	PHA
	LDA	VIA_FLOPPY_CONTROL_PORT
	ORA.I	0B00000100
	STA	VIA_FLOPPY_CONTROL_PORT
	STZ	FLOPPY_SIDE
	PLA
	RTS

>FLOPPY_SIDE_B
	PHA
	LDA	VIA_FLOPPY_CONTROL_PORT
	AND.I	0B11111011
	STA	VIA_FLOPPY_CONTROL_PORT
	LDA.I	1
	STA	FLOPPY_SIDE
	PLA
	RTS

>FLOPPY_SIDE_SWITCH
	PHA
	LDA	FLOPPY_SIDE
	BEQ	_FLOPPY_SIDE_SWITCH_B
	JSR	FLOPPY_SIDE_A
	BRA	_FLOPPY_SIDE_SWITCH_END
>_FLOPPY_SIDE_SWITCH_B
	JSR	FLOPPY_SIDE_B
>_FLOPPY_SIDE_SWITCH_END
	PLA
	RTS

>FLOPPY_INDEX
	PHA				; push A
>_FLOPPY_INDEX_LEAVE
	LDA	VIA_FLOPPY_CONTROL_PORT	; load control port to test index
	AND.I	0B01000000		; mask index bit
	BEQ	_FLOPPY_INDEX_LEAVE	; if set, keep looping until index region is left
>_FLOPPY_INDEX_LOOP
	LDA	VIA_FLOPPY_CONTROL_PORT	; load control port to test index
	AND.I	0B01000000		; mask index bit
	BNE	_FLOPPY_INDEX_LOOP	; if not set, keep looping until index found
	PLA				; restore A
	RTS				; return
;;;
; called immediately on the byte before write section
; 32 cycles till start good luck
>FLOPPY_WRITE_SECTOR
	; 6
	LDA	VIA_FLOPPY_CONTROL_PORT ; 4 10
	ORA.I	0B00010000 ; 2 12
	STA	VIA_FLOPPY_CONTROL_PORT ; 4 16
	LDA.I	0XFF ; 2 18
	STA	VIA_FLOPPY_DATA_PORT ; 4 22
	STA	VIA_FLOPPY_DATA_DIR ; 4 26
	; writing now with 0xff starting
	WAI
	LDX.I	30
	LDA.I	0B00111111
	STA	VIA_FLOPPY_DATA_PORT
>_FLOPPY_WRITE_SECTOR_HEADER
	WAI
	LDA	VIA_FLOPPY_DATA_PORT
	DEX
	BNE	_FLOPPY_WRITE_SECTOR_HEADER

	; ver code
	LDA.I	ASCII_C
	ASL
	ORA.I	0B01010101
	STA	VIA_FLOPPY_DATA_PORT
	WAI
	LDA.I	ASCII_C
	ORA.I	0B01010101
	STA	VIA_FLOPPY_DATA_PORT
	WAI
	LDA.I	ASCII_B
	ASL
	ORA.I	0B01010101
	STA	VIA_FLOPPY_DATA_PORT
	WAI
	LDA.I	ASCII_B
	ORA.I	0B01010101
	STA	VIA_FLOPPY_DATA_PORT
	WAI

	; sector id
	LDA	FLOPPY_SEC_ID
	ASL
	ORA.I	0B01010101
	STA	VIA_FLOPPY_DATA_PORT
	WAI
	LDA	FLOPPY_SEC_ID
	ORA.I	0B01010101
	STA	VIA_FLOPPY_DATA_PORT
	WAI

	; pointer
	LDA	FLOPPY_SEC_PTR
	ASL
	ORA.I	0B01010101
	STA	VIA_FLOPPY_DATA_PORT
	WAI
	LDA	FLOPPY_SEC_PTR
	ORA.I	0B01010101
	STA	VIA_FLOPPY_DATA_PORT
	WAI
	LDA	FLOPPY_SEC_PTR 1
	ASL
	ORA.I	0B01010101
	STA	VIA_FLOPPY_DATA_PORT
	WAI
	LDA	FLOPPY_SEC_PTR 1
	ORA.I	0B01010101
	STA	VIA_FLOPPY_DATA_PORT
	WAI

	; length
	LDA	FLOPPY_SEC_LEN
	ASL
	ORA.I	0B01010101
	STA	VIA_FLOPPY_DATA_PORT
	WAI
	LDA	FLOPPY_SEC_LEN
	ORA.I	0B01010101
	STA	VIA_FLOPPY_DATA_PORT
	WAI

	; data
	LDX.I	0
>_FLOPPY_WRITE_SECTOR_DATA
	LDA.X	FLOPPY_PAGE
	ASL
	ORA.I	0B01010101
	STA	VIA_FLOPPY_DATA_PORT
	WAI
	LDA.X	FLOPPY_PAGE
	ORA.I	0B01010101
	STA	VIA_FLOPPY_DATA_PORT
	WAI
	INX
	BNE	_FLOPPY_WRITE_SECTOR_DATA

	; end cap
	; stop write
	LDA.I	0XFF
	STA	VIA_FLOPPY_DATA_PORT
	WAI
	LDA	VIA_FLOPPY_DATA_PORT
	STZ	VIA_FLOPPY_DATA_DIR
	LDA	VIA_FLOPPY_CONTROL_PORT
	AND.I	0B11101111
	STA	VIA_FLOPPY_CONTROL_PORT
	WAI
	RTS

>FLOPPY_WRITE_ANCHOR
	; 6
	LDA	VIA_FLOPPY_CONTROL_PORT ; 4 10
	ORA.I	0B00010000 ; 2 12
	STA	VIA_FLOPPY_CONTROL_PORT ; 4 16
	LDA.I	0XFF ; 2 18
	STA	VIA_FLOPPY_DATA_PORT ; 4 22
	STA	VIA_FLOPPY_DATA_DIR ; 4 26
	; writing now with 0xff starting
	WAI
	LDX.I	30
	LDA.I	0B00111111
	STA	VIA_FLOPPY_DATA_PORT
>_FLOPPY_WRITE_ANCHOR_HEADER
	WAI
	LDA	VIA_FLOPPY_DATA_PORT
	DEX
	BNE	_FLOPPY_WRITE_ANCHOR_HEADER

	; ver code
	LDA.I	ASCII_C
	ASL
	ORA.I	0B01010101
	STA	VIA_FLOPPY_DATA_PORT
	WAI
	LDA.I	ASCII_C
	ORA.I	0B01010101
	STA	VIA_FLOPPY_DATA_PORT
	WAI
	LDA.I	ASCII_B
	ASL
	ORA.I	0B01010101
	STA	VIA_FLOPPY_DATA_PORT
	WAI
	LDA.I	ASCII_B
	ORA.I	0B01010101
	STA	VIA_FLOPPY_DATA_PORT
	WAI

	; 0 sector id
	LDA.I	0B01010101
	STA	VIA_FLOPPY_DATA_PORT
	WAI
	WAI

	; end cap
	; stop write
	LDA.I	0XFF
	STA	VIA_FLOPPY_DATA_PORT
	WAI
	LDA	VIA_FLOPPY_DATA_PORT
	STZ	VIA_FLOPPY_DATA_DIR
	LDA	VIA_FLOPPY_CONTROL_PORT
	AND.I	0B11101111
	STA	VIA_FLOPPY_CONTROL_PORT
	WAI
	RTS

; utility functions for being called by os

; formats the entire disk be careful
>FLOPPY_FORMAT
	PHA
	PHX
	PHY

	JSR	FLOPPY_ENTER
	
	LDA.I	0
	STA.Z	VR5
	LDA.I	FLOPPY_PAGE > 8
	STA.Z	VR0 1
	JSR	PAGESET

	LDA.I	0
	STA	FLOPPY_SEC_LEN

	LDA.I	0
	STA	FLOPPY_SEC_PTR
	STA	FLOPPY_SEC_PTR 1

	JSR	FLOPPY_CALIBRATE_TRACK
	; t0sA
	LDA.Z	VR8
	PHA
	LDA.I	0
	STA.Z	VR8 ; vr8 is track number
>_FLOPPY_FORMAT_TRACK_LOOP1
	; FLOPPY_WRITE_SECTOR OVERWRITES X!
	LDY.I	1 ; Y is sector number
	LDA.Z	VR8
	JSR	FLOPPY_SET_TRACK
	JSR	FLOPPY_INDEX
	JSR	FLOPPY_WRITE_ANCHOR	; anchor written at very start of index
	; very precise: anchor and sector writes return during the FIRST BYTE AFTER THE END CAP
	; right now like in the first quarter of the after cap byte
	; lets give a 10 byte spacing that seems pretty safe
	; count 9 then write sector
>_FLOPPY_FORMAT_SECTOR_LOOP1
	LDA	VIA_FLOPPY_DATA_PORT ; clear wai
	WAI	; 1
	LDA	VIA_FLOPPY_DATA_PORT ; clear wai
	WAI	; 2
	LDA	VIA_FLOPPY_DATA_PORT ; clear wai
	WAI	; 3
	LDA	VIA_FLOPPY_DATA_PORT ; clear wai
	WAI	; 4
	LDA	VIA_FLOPPY_DATA_PORT ; clear wai
	WAI	; 5
	LDA	VIA_FLOPPY_DATA_PORT ; clear wai
	WAI	; 6
	LDA	VIA_FLOPPY_DATA_PORT ; clear wai
	WAI	; 7
	LDA	VIA_FLOPPY_DATA_PORT ; clear wai
	WAI	; 8
	LDA	VIA_FLOPPY_DATA_PORT ; clear wai
	STY	FLOPPY_SEC_ID
	WAI	; 9
	JSR	FLOPPY_WRITE_SECTOR
	INY
	CPY.I	21
	BNE	_FLOPPY_FORMAT_SECTOR_LOOP1

	; wrote 20 sectors lets go to the next track
	INC.Z	VR8
	LDA.Z	VR8
	CMP.I	40
	BNE	_FLOPPY_FORMAT_TRACK_LOOP1

	JSR	FLOPPY_CALIBRATE_TRACK
	; t0sA
	JSR	FLOPPY_SIDE_B
	; t0sB
	LDA.I	0
	STA.Z	VR8
>_FLOPPY_FORMAT_TRACK_LOOP2
	LDY.I	1
	LDA.Z	VR8
	JSR	FLOPPY_SET_TRACK
	JSR	FLOPPY_INDEX
	JSR	FLOPPY_WRITE_ANCHOR	; anchor written at very start of index
	; very precise: anchor and sector writes return during the FIRST BYTE AFTER THE END CAP
	; right now like in the first quarter of the after cap byte
	; lets give a 10 byte spacing that seems pretty safe
	; count 9 then write sector
>_FLOPPY_FORMAT_SECTOR_LOOP2
	LDA	VIA_FLOPPY_DATA_PORT ; clear wai
	WAI	; 1
	LDA	VIA_FLOPPY_DATA_PORT ; clear wai
	WAI	; 2
	LDA	VIA_FLOPPY_DATA_PORT ; clear wai
	WAI	; 3
	LDA	VIA_FLOPPY_DATA_PORT ; clear wai
	WAI	; 4
	LDA	VIA_FLOPPY_DATA_PORT ; clear wai
	WAI	; 5
	LDA	VIA_FLOPPY_DATA_PORT ; clear wai
	WAI	; 6
	LDA	VIA_FLOPPY_DATA_PORT ; clear wai
	WAI	; 7
	LDA	VIA_FLOPPY_DATA_PORT ; clear wai
	WAI	; 8
	LDA	VIA_FLOPPY_DATA_PORT ; clear wai
	STY	FLOPPY_SEC_ID
	WAI	; 9
	JSR	FLOPPY_WRITE_SECTOR
	INY
	CPY.I	21
	BNE	_FLOPPY_FORMAT_SECTOR_LOOP2

	; wrote 20 sectors lets go to the next track
	INC.Z	VR8
	LDA.Z	VR8
	CMP.I	40
	BNE	_FLOPPY_FORMAT_TRACK_LOOP2

	PLA
	STA.Z	VR8

	JSR	FLOPPY_EXIT

	PLY
	PLX
	PLA
	RTS

; need side track and sector
; track byte VR4/1
; sector byte VR4/2
; 0 - 39 side A
; 0x80 + 0 - 39 side B
>FLOPPY_READ
	PHA
	PHX
	JSR	FLOPPY_ENTER
	JSR	FLOPPY_CALIBRATE_TRACK
	LDA.Z	VR4
	CMP.I	0X80
	BLS	_FLOPPY_READ_SIDE
	JSR	FLOPPY_SIDE_B
>_FLOPPY_READ_SIDE
	AND.I	0X7F
	JSR	FLOPPY_SET_TRACK
	; on correct track and side
>_FLOPPY_READ_ALIGN
	WAI
	LDA	VIA_FLOPPY_DATA_PORT
	CMP.I	0B00111111
	BEQ	_FLOPPY_READ_LOCKED
	LDA	VIA_FLOPPY_CONTROL_PORT
	AND.I	0B11110111
	STA	VIA_FLOPPY_CONTROL_PORT
	WAI
	LDA	VIA_FLOPPY_DATA_PORT
	LDA	VIA_FLOPPY_CONTROL_PORT
	ORA.I	0B00001000
	STA	VIA_FLOPPY_CONTROL_PORT
	WAI
	LDA	VIA_FLOPPY_DATA_PORT
	BRA	_FLOPPY_READ_ALIGN
>_FLOPPY_READ_LOCKED
	WAI
	LDA	VIA_FLOPPY_DATA_PORT
	CMP.I	0B00111111
	BEQ	_FLOPPY_READ_LOCKED
	; check verif bytes
	; CB ->
	; 67 66
	; 0b01000011 0b01000010
	;
	; 0b11010111
	; 0b01010111
	; 0b11010101
	; 0b01010111
	CMP.I	0B11010111
	BNE	_FLOPPY_READ_ALIGN
	WAI
	LDA	VIA_FLOPPY_DATA_PORT
	CMP.I	0B01010111
	BNE	_FLOPPY_READ_ALIGN
	WAI
	LDA	VIA_FLOPPY_DATA_PORT
	CMP.I	0B11010101
	BNE	_FLOPPY_READ_ALIGN
	WAI
	LDA	VIA_FLOPPY_DATA_PORT
	CMP.I	0B01010111
	BNE	_FLOPPY_READ_ALIGN

	; good get sector id
	WAI
	LDA	VIA_FLOPPY_DATA_PORT
	SEC
	ROR
	WAI
	AND	VIA_FLOPPY_DATA_PORT
	CMP.Z	VR4 1
	BNE	_FLOPPY_READ_ALIGN	; skip this sector if not target
	STA	FLOPPY_SEC_ID
	; get pointer
	WAI
	LDA	VIA_FLOPPY_DATA_PORT
	SEC
	ROR
	WAI
	AND	VIA_FLOPPY_DATA_PORT
	STA	FLOPPY_SEC_PTR
	WAI
	LDA	VIA_FLOPPY_DATA_PORT
	SEC
	ROR
	WAI
	AND	VIA_FLOPPY_DATA_PORT
	STA	FLOPPY_SEC_PTR 1
	; get len
	WAI
	LDA	VIA_FLOPPY_DATA_PORT
	SEC
	ROR
	WAI
	AND	VIA_FLOPPY_DATA_PORT
	STA	FLOPPY_SEC_LEN
	; get data
	LDX.I	0
>_FLOPPY_READ_DATA
	WAI
	LDA	VIA_FLOPPY_DATA_PORT
	SEC
	ROR
	WAI
	AND	VIA_FLOPPY_DATA_PORT
	STA.X	FLOPPY_PAGE
	INX
	BNE	_FLOPPY_READ_DATA
	; done

	JSR	FLOPPY_EXIT

	PLX
	PLA
	RTS

; vr4/1 side track
; vr4/2 sec
; use data in floppy sec vars
>FLOPPY_WRITE
	PHA
	PHX
	JSR	FLOPPY_ENTER
	JSR	FLOPPY_CALIBRATE_TRACK
	LDA.Z	VR4
	CMP.I	0X80
	BLS	_FLOPPY_WRITE_SIDE
	JSR	FLOPPY_SIDE_B
>_FLOPPY_WRITE_SIDE
	AND.I	0X7F
	JSR	FLOPPY_SET_TRACK
	; on correct track and side
>_FLOPPY_WRITE_ALIGN
	WAI
	LDA	VIA_FLOPPY_DATA_PORT
	CMP.I	0B00111111
	BEQ	_FLOPPY_WRITE_LOCKED
	LDA	VIA_FLOPPY_CONTROL_PORT
	AND.I	0B11110111
	STA	VIA_FLOPPY_CONTROL_PORT
	WAI
	LDA	VIA_FLOPPY_DATA_PORT
	LDA	VIA_FLOPPY_CONTROL_PORT
	ORA.I	0B00001000
	STA	VIA_FLOPPY_CONTROL_PORT
	WAI
	LDA	VIA_FLOPPY_DATA_PORT
	BRA	_FLOPPY_WRITE_ALIGN
>_FLOPPY_WRITE_LOCKED
	WAI
	LDA	VIA_FLOPPY_DATA_PORT
	CMP.I	0B00111111
	BEQ	_FLOPPY_WRITE_LOCKED
	; check verif bytes
	; CB ->
	; 67 66
	; 0b01000011 0b01000010
	;
	; 0b11010111
	; 0b01010111
	; 0b11010101
	; 0b01010111
	CMP.I	0B11010111
	BNE	_FLOPPY_WRITE_ALIGN
	WAI
	LDA	VIA_FLOPPY_DATA_PORT
	CMP.I	0B01010111
	BNE	_FLOPPY_WRITE_ALIGN
	WAI
	LDA	VIA_FLOPPY_DATA_PORT
	CMP.I	0B11010101
	BNE	_FLOPPY_WRITE_ALIGN
	WAI
	LDA	VIA_FLOPPY_DATA_PORT
	CMP.I	0B01010111
	BNE	_FLOPPY_WRITE_ALIGN

	; good get sector id
	WAI
	LDA	VIA_FLOPPY_DATA_PORT
	SEC
	ROR
	WAI
	AND	VIA_FLOPPY_DATA_PORT
	INC				; want to find sector before so add 1 to be target
	CMP.Z	VR4 1
	BNE	_FLOPPY_WRITE_ALIGN	; skip this sector if not target
	CMP.I	1
	BEQ	_FLOPPY_WRITE_COUNT
	; get pointer
	WAI
	LDA	VIA_FLOPPY_DATA_PORT
	SEC
	ROR
	WAI
	AND	VIA_FLOPPY_DATA_PORT
	STA	FLOPPY_SEC_PTR
	WAI
	LDA	VIA_FLOPPY_DATA_PORT
	SEC
	ROR
	WAI
	AND	VIA_FLOPPY_DATA_PORT
	; get len
	WAI
	LDA	VIA_FLOPPY_DATA_PORT
	SEC
	ROR
	WAI
	AND	VIA_FLOPPY_DATA_PORT
	; get data
	LDX.I	0
>_FLOPPY_WRITE_DATA
	WAI
	LDA	VIA_FLOPPY_DATA_PORT
	SEC
	ROR
	WAI
	AND	VIA_FLOPPY_DATA_PORT
	INX
	BNE	_FLOPPY_WRITE_DATA

>_FLOPPY_WRITE_COUNT
	; currently on end cap byte
	LDA	VIA_FLOPPY_DATA_PORT ; clear wai
	WAI ; cap
	LDA	VIA_FLOPPY_DATA_PORT ; clear wai
	WAI ; 1
	LDA	VIA_FLOPPY_DATA_PORT ; clear wai
	WAI ; 2
	LDA	VIA_FLOPPY_DATA_PORT ; clear wai
	WAI ; 3
	LDA	VIA_FLOPPY_DATA_PORT ; clear wai
	WAI ; 4
	LDA	VIA_FLOPPY_DATA_PORT ; clear wai
	WAI ; 5
	LDA	VIA_FLOPPY_DATA_PORT ; clear wai
	WAI ; 6
	LDA	VIA_FLOPPY_DATA_PORT ; clear wai
	WAI ; 7
	LDA	VIA_FLOPPY_DATA_PORT ; clear wai
	WAI ; 8
	LDA	VIA_FLOPPY_DATA_PORT ; clear wai
	LDA.Z	VR4 1
	STA	FLOPPY_SEC_ID
	WAI ; 9
	JSR	FLOPPY_WRITE_SECTOR

	JSR	FLOPPY_EXIT

	PLX
	PLA
	RTS
