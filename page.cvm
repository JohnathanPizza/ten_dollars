; if proc id is 0xff then no proc claims that row
; if home is 0xff then not in map yet
; if home is >= 0x80 then data page, relative id = home - 0x80
; if map has 0xff then nothing at that spot
; home of 0x80 is the zero page
; home of 0x81 is the stack page

=PAGE_MAP_RAM_COUNT	0X70	; 0x1000 - 0x7fff
=PAGE_MAP_RAM_BASE	0X1000

; vr4/1 first index
; vr4/2 second index
>PAGE_MAP_SWAP
	PHA
	PHX
	LDX.Z	VR4
	LDA.X	PAGE_MAP
	STA.Z	VR8
	LDX.Z	VR4 1
	LDA.X	PAGE_MAP
	LDX.Z	VR4
	STA.X	PAGE_MAP
	LDA.Z	VR8
	LDX.Z	VR4 1
	STA.X	PAGE_MAP

	LDA.Z	VR4
	CLC
	ADC.I	PAGE_MAP_RAM_BASE > 8
	STA.Z	VR4
	LDA.Z	VR4 1
	CLC
	ADC.I	PAGE_MAP_RAM_BASE > 8
	STA.Z	VR4 1

	JSR	PAGESWAP

	LDA.Z	VR4
	SEC
	SBC.I	PAGE_MAP_RAM_BASE > 8
	STA.Z	VR4
	LDA.Z	VR4 1
	SEC
	SBC.I	PAGE_MAP_RAM_BASE > 8
	STA.Z	VR4 1
	PLX
	PLA
	RTS

; A number of pages to go in RAM
; ret A spot where those pages should start from
; may not all be clear
>PAGE_MAP_LARGEST
	; vr8/1 highset count
	; vr8/2 highest count base
	; vr9/1 current count
	; vr9/2 current base
	; vr10/1 pages to find
	; vr11 map ptr
	STA.Z	VR10
	PHX
	
	STZ.Z	VR8
	STZ.Z	VR8 1
	
	LDA.I	PAGE_MAP_RAM_COUNT
	SEC
	SBC.Z	VR10
	STA.Z	VR9 1

>_PAGE_MAP_LARGEST_LOOP
	STZ.Z	VR9
	LDA.Z	VR9 1
	DEC
	CLC
	ADC.Z	VR10
	TAX
>_PAGE_MAP_LARGEST_LOOP2
	LDA.X	PAGE_MAP
	CMP.I	0XFF
	BNE	_PAGE_MAP_LARGEST_LOOP2_OCC
	INC.Z	VR9
>_PAGE_MAP_LARGEST_LOOP2_OCC
	CPX.Z	VR9 1
	BEQ	_PAGE_MAP_LARGEST_LOOP2_CALC
	DEX
	BRA	_PAGE_MAP_LARGEST_LOOP2
>_PAGE_MAP_LARGEST_LOOP2_CALC
	LDA.Z	VR8
	CMP.Z	VR9
	BGE	_PAGE_MAP_LARGEST_LOOP2_KEEP
	LDA.Z	VR9
	STA.Z	VR8
	LDA.Z	VR9 1
	STA.Z	VR8 1
>_PAGE_MAP_LARGEST_LOOP2_KEEP
	LDA.Z	VR9 1
	BEQ	_PAGE_MAP_LARGEST_EXIT
	DEC.Z	VR9 1
	BRA	_PAGE_MAP_LARGEST_LOOP
>_PAGE_MAP_LARGEST_EXIT
	PLX
	LDA.Z	VR8 1
	RTS
