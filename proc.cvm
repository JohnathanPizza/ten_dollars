; vr11 new process id
; if 0xff then none open
; else that is the new process id DONT LOSE IT!
=PROC_MAX_COUNT	0x10

>PROC_NEW
	PHA
	PHX
	LDX.I	0
>_PROC_NEW_LOOP
	LDA.X	PROC_ARRAY_STATE
	CMP.I	PROC_STATE_NULL
	BEQ	_PROC_NEW_FOUND
	INX
	CPX.I	PROC_MAX_COUNT
	BNE	_PROC_NEW_LOOP
	LDA.I	0XFF
	STA.Z	VR11
	PLX
	PLA
	RTS
>_PROC_NEW_FOUND
	STX.Z	VR11
	PLX
	PLA
	RTS

; A procid
>PROC_EVALUATE

; given a rom/ram program code

; grab a new proc
; check for C + 2 pages
; claim
; arrange a line of C pages
; fill with program code
; adjust
; clear zero page and stack
; init pcb
; update state to ready

; A procid
>PROC_CREATE
	PHA
	PHX
	TAX
	LDA.X	PROC_ARRAY_A	; A will initially store program index, <0x80 is rom, >=0x80 is disk
	BPL	_PROC_CREATE_ROM
	; disk program index idk yet
	PLA
	PLX
	RTS
>_PROC_CREATE_ROM
	CLC
	ADC.X	PROC_ARRAY_A
	ADC.X	PROC_ARRAY_A
	ASL ; x6
	TAX
	LDA.X	ROM_PROGRAM_ARRAY	; start ptr
	STA.Z	VR8
	LDA.X	ROM_PROGRAM_ARRAY 1
	STA.Z	VR8 1
	LDA.X	ROM_PROGRAM_ARRAY 2	; code len
	STA.Z	VR9
	LDA.X	ROM_PROGRAM_ARRAY 3
	STA.Z	VR9 1
	LDA.X	ROM_PROGRAM_ARRAY 4	; full len
	STA.Z	VR10
	LDA.X	ROM_PROGRAM_ARRAY 5
	STA.Z	VR10 1

	; program info is loaded in vr8-10
	; calculate needed pages
	; total page count = 2 + (full len - 1 > 8) + 1
	SEC
	LDA.Z	VR10
	SBC.I	1
	LDA.Z	VR10 1
	SBC.I	0
	INC
	INC
	INC
	; A has pages needed
	STA.Z	VR11
	LDA	PAGE_TABLE_EMPTY
	CMP.Z	VR11
	BLS	_PROC_CREATE_FEW_PAGES
	; finish this
>_PROC_CREATE_FEW_PAGES

;; vr4 proc id
;>PROC_ENTER
;	LDY.Z	VR4
;	STY	PROC_ACTIVE_ID
;	LDX.Y	PROC_ARRAY_S
;	TXS
;	LDX.Y	PROC_ARRAY_P
;	PHX
;	TYA
;	ASL
;	TAX
;	PLP
;	JMP.XP	PROC_ARRAY_PC
;
>PROC_UNPAUSE
	LDA	PROC_PAUSE_A
	LDY	PROC_PAUSE_Y
	LDX	PROC_PAUSE_S
	TXS
	LDX	PROC_PAUSE_P
	PHX
	LDX	PROC_PAUSE_X
	PLP
	JMP.P	PROC_PAUSE_PC
