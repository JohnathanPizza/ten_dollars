; default shell program
; use for basic interaction with system

; ZP map
=_SHELL_ARG_PTR		0 	; 1
=_SHELL_ARG_LEN		1 	; 1
=_SHELL_ARG_END		2 	; 1
=_SHELL_INPUT_BUF	0X10	; 0x40

; constants
=_SHELL_INPUT_BUF_LEN	0X40

>SHELL_START

	; get the process pointer offset to adjust strings
	LDA.I	BC_PTROFF			; interrupt to get offset in VR11
	BRK
	LDA.I	_SHELL_PTR_ARRAY_END - _SHELL_PTR_ARRAY / 2	; load length of pointer array to adjust in VR8
	STA.Z	VR8
	LDA.I	_SHELL_PTR_ARRAY_END - _SHELL_PTR_ARRAY / 2 > 8
	STA.Z	VR8 1
	CLC					; add offset to pointer to array of string pointers to adjust and store in VR9
	LDA.I	_SHELL_PTR_ARRAY
	ADC.Z	VR11
	STA.Z	VR9
	LDA.I	_SHELL_PTR_ARRAY > 8
	ADC.Z	VR11 1
	STA.Z	VR9 1
	LDY.I	1				; load 1 in Y for easy access to high byte without losing C flag during addition
>_SHELL_PTR_ADJUST_LOOP
	LDA.Z	VR8				; test if count is 0
	ORA.Z	VR8 1
	BRA	_SHELL_PTR_ADJUST_LOOP_DONE	; if so done adjusting
	CLC					; add the next pointer in adjustment array with offset
	LDA.ZP	VR9
	ADC.Z	VR11
	STA.ZP	VR9
	LDA.ZPY	VR9
	ADC.Z	VR11 1
	STA.ZPY	VR9
	JSR	INC9				; + 2 to get next pointer in array
	JSR	INC9
	JSR	DEC8				; dec count by 1
	BRA	_SHELL_PTR_ADJUST_LOOP		; loop
>_SHELL_PTR_ADJUST_LOOP_DONE

>_SHELL_LOOP

	; signal for user input with header
	LDA	_SHELL_HEADER_STR		; load header string
	STA.Z	VR0
	LDA	_SHELL_HEADER_STR 1
	STA.Z	VR0 1
	JSR	PRINTS				; print

	; get user input
	LDA.I	_SHELL_INPUT_BUF		; load pointer to input buffer
	STA.Z	VR0				; set read buffer to input buffer
	STZ.Z	VR0 1
	LDA.I	_SHELL_INPUT_BUF_LEN		; load input buffer size
	STA.Z	VR4
	LDA.I	BC_READ				; load read code
	BRK					; get input
	JSR	PRINTL				; reflect input
	
	; set initial argument var values
	JSR	STRLEAD				; trim leading whitespace in input to get first arg
	LDA.Z	VR11				; set argument pointer var
	STA.Z	_SHELL_ARG_PTR
	STA.Z	VR0				; also set VR0 to trimmed str pointer (VR0 1 is still 0x00)
	JSR	STRWORDLEN			; get length of argument
	LDA.Z	VR11				; test argument length
	BEQ	_SHELL_LOOP			; go back to main loop if length is 0
	STA.Z	_SHELL_ARG_LEN			; set argument length var
	TAY					; move arg len to Y to access character that ends the argument (WS or nul char)
	LDA.ZPY	VR0				; load ending char
	STA.Z	_SHELL_ARG_END			; set as argument ending char var
	LDA.I	ASCII_NUL			; load nul char value
	STA.ZPY	VR0				; set ending char as nul char for easy use of string functions later

	; search for given command
	LDA.Z	_SHELL_ARG_PTR			; load pointer to the start of the first argument
	STA.Z	VR1
	STZ.Z	VR1 1				; zero here because the input buffer is in the zero page so the arg pointer must be too
	LDA.Z	_SHELL_ARG_LEN			; load total length of argument for strncmp
	STA.Z	VR4
	LDX.I	0				; set array search index to 0
>_SHELL_SEARCH_LOOP
	LDA.X	_SHELL_FUNC_STR_PTR_ARRAY	; load next command string pointer from array
	STA.Z	VR0
	LDA.X	_SHELL_FUNC_STR_PTR_ARRAY 1
	STA.Z	VR0 1
	JSR	STRLEN				; get length of the command string
	CMP.Z	VR4				; test if given argument and command are same length
	BNE	_SHELL_SEARCH_LOOP_SKIP		; if not then go to next command
	JSR	STRNCMP				; compare argument string to command string
	CMP.I	0				; test if they were equal
	BNE	_SHELL_SEARCH_LOOP_SKIP		; if not then go to next command
	JMP.XP	_SHELL_FUNC_ARRAY		; use parallel function pointer array to call func corresponding to command string
>_SHELL_SEARCH_LOOP_SKIP
	INX					; X + 2 to set at next command string
	INX
	CPX.I	_SHELL_FUNC_STR_PTR_ARRAY_END - _SHELL_FUNC_STR_PTR_ARRAY	; test if searched through all command strings
	BNE	_SHELL_SEARCH_LOOP		; loop again on new command string if not

	; no matching command string found
	LDA.I	ASCII_QUOTE			; print " to wrap given command argument
	JSR	PRINTC
	LDA.Z	_SHELL_ARG_PTR			; load pointer to given command
	STA.Z	VR0
	STZ.Z	VR0 1
	JSR	PRINTS				; print given command
	LDA.I	ASCII_QUOTE			; add another "
	JSR	PRINTC
	LDA	_SHELL_COMMAND_ERROR_STR	; load bad command error string
	STA.Z	VR0
	LDA	_SHELL_COMMAND_ERROR_STR 1
	STA.Z	VR0 1
	JSR	PRINTL				; print
	JMP	_SHELL_LOOP			; go back to main loop and get new input
	
;==========

; command strings

>_SHELL_RUN_STR
"run\0
>_SHELL_RUND_STR
"rund\0
>_SHELL_EXIT_STR
"exit\0
>_SHELL_CF_STR
"cf\0
>_SHELL_KILL_STR
"kill\0
>_SHELL_SYS_STR
"sys\0
>_SHELL_ME_STR
"me\0
>_SHELL_PEEK_STR
"peek\0
>_SHELL_POKE_STR
"poke\0

;==========

; other strings

>_SHELL_MISSING_ARG_STR_RAW
"Missing argument(s)\0

>_SHELL_COMMAND_ERROR_STR_RAW
" is not a command\0

>_SHELL_HEADER_STR_RAW
"(shell) # \0

>_SHELL_SYS_OUT1_RAW	; header string for processes
"PID NAME             STATE OFFSET STACK CODE# DATA#\0

>_SHELL_SYS_OUT2_RAW
"/32 processes active\0

>_SHELL_SYS_OUT3_RAW
"/240 pages active\0

>_SHELL_SYS_OUT4_RAW
" owns file permissions\0

>_SHELL_SYS_OUT5_RAW
"PAGEID PID HOME MAP\0	; header for page information

;==========

; array of all string pointers that need to be adjusted

>_SHELL_PTR_ARRAY		; label for the array of all string pointers to adjust
>_SHELL_FUNC_STR_PTR_ARRAY	; label for the subarray of command strings

$_SHELL_RUN_STR
$_SHELL_RUND_STR
$_SHELL_EXIT_STR
$_SHELL_CF_STR
$_SHELL_KILL_STR
$_SHELL_SYS_STR
$_SHELL_ME_STR
$_SHELL_PEEK_STR
$_SHELL_POKE_STR

>_SHELL_FUNC_STR_PTR_ARRAY_END	; end label for subarray of command strings

; load these labels for strings instead of the raw labels where the strings are actually located
; these labels point to the adjusted pointer value, so do LDA	_SHELL_MISSING_ARG_STR and no adjustment is needed while still looking clean
;Jaking it to Ryan, so good

>_SHELL_MISSING_ARG_STR
$_SHELL_MISSING_ARG_STR_RAW
>_SHELL_COMMAND_ERROR_STR
$_SHELL_COMMAND_ERROR_STR_RAW
>_SHELL_HEADER_STR
$_SHELL_HEADER_STR_RAW
>_SHELL_SYS_OUT1
$_SHELL_SYS_OUT1_RAW
>_SHELL_SYS_OUT2
$_SHELL_SYS_OUT2_RAW
>_SHELL_SYS_OUT3
$_SHELL_SYS_OUT3_RAW
>_SHELL_SYS_OUT4
$_SHELL_SYS_OUT4_RAW
>_SHELL_SYS_OUT5
$_SHELL_SYS_OUT5_RAW

>_SHELL_PTR_ARRAY_END

;==========

; function pointer array for command functions
; parallel to command strings array

>_SHELL_FUNC_ARRAY
$_SHELL_RUN_FUNC
$_SHELL_RUND_FUNC
$_SHELL_EXIT_FUNC
$_SHELL_CF_FUNC
$_SHELL_KILL_FUNC
$_SHELL_SYS_FUNC
$_SHELL_ME_FUNC
$_SHELL_PEEK_FUNC
$_SHELL_POKE_FUNC

;==========

; command functions

;==================================================

>_SHELL_RUN_FUNC
	JSR	_SHELL_NEXT_ARG
	CMP.I	0
	BNE	_SHELL_RUN_FUNC_ARG
	JSR	_SHELL_MISSING_ARG_ERROR
	JMP	_SHELL_LOOP
>_SHELL_RUN_FUNC_ARG
	LDA.Z	_SHELL_ARG_PTR					; load pointer to name arg
	STA.Z	VR0						; set in VR0 for ROM name finder
	STZ.Z	VR0 1
	JSR	ROM_PROGRAM_GET
	CMP.I	0XFF
	BEQ	_SHELL_RUN_FUNC_FAIL
	STA.Z	VR4
	LDA.I	BC_SPAWN_ROM
	BRK
	LDA.Z	VR11
	STA.Z	VR4
	LDA.I	BC_FOCUS_CHANGE
	BRK
	LDA.I	BC_WAIT_FOCUS
	BRK
>_SHELL_RUN_FUNC_FAIL
	JMP	_SHELL_LOOP

>_SHELL_RUND_FUNC
	JSR	_SHELL_NEXT_ARG
	CMP.I	0
	BNE	_SHELL_RUND_FUNC_ARG
	JSR	_SHELL_MISSING_ARG_ERROR
	JMP	_SHELL_LOOP
>_SHELL_RUND_FUNC_ARG
	LDA.I	BC_FILE_CLAIM
	BRK
	LDA.Z	VR11
	BEQ	_SHELL_RUND_FUNC_FAIL
	LDA.Z	_SHELL_ARG_PTR					; load pointer to name arg
	STA.Z	VR0						; set in VR0 for file open
	STZ.Z	VR0 1
	LDA.I	FILE_OP_OPEN_A					; *change to find and pass file id?
	STA.Z	VR6
	LDA.I	BC_FILE_OP
	BRK
	LDA.Z	VR11
	BNE	_SHELL_RUND_FUNC_FAIL
	LDA.I	BC_SPAWN_DISK
	BRK
	LDA.Z	VR11
	STA.Z	VR4
	LDA.I	BC_FILE_RELEASE
	BRK
	LDA.I	BC_FOCUS_CHANGE
	BRK
	LDA.I	BC_WAIT_FOCUS
	BRK
>_SHELL_RUND_FUNC_FAIL
	JMP	_SHELL_LOOP

>_SHELL_EXIT_FUNC
	LDA.I	BC_EXIT
	BRK

>_SHELL_CF_FUNC
	JSR	_SHELL_NEXT_ARG
	CMP.I	0
	BNE	_SHELL_CF_FUNC_ARG
	JSR	_SHELL_MISSING_ARG_ERROR
	JMP	_SHELL_LOOP
>_SHELL_CF_FUNC_ARG
	LDA.Z	_SHELL_ARG_PTR
	STA.Z	VR0
	STZ.Z	VR0 1
	JSR	STRTONUM
	CMP.I	FALSE
	BEQ	_SHELL_CF_FUNC_FAIL
	LDA.Z	VR11
	STA.Z	VR4
	LDA.I	BC_FOCUS_CHANGE
	BRK
	LDA.I	BC_WAIT_FOCUS
	BRK
>_SHELL_CF_FUNC_FAIL
	JMP	_SHELL_LOOP

>_SHELL_ME_FUNC
	LDA	PROC_ACTIVE_ID
	JSR	PRINTH
	LDA.I	ASCII_LF
	JSR	PRINTC
	JMP	_SHELL_LOOP

>_SHELL_KILL_FUNC
	; dangerous
	JSR	_SHELL_NEXT_ARG
	CMP.I	0
	BNE	_SHELL_KILL_FUNC_ARG
	JSR	_SHELL_MISSING_ARG_ERROR
	JMP	_SHELL_LOOP
>_SHELL_KILL_FUNC_ARG
	LDA.Z	_SHELL_ARG_PTR
	STA.Z	VR0
	STZ.Z	VR0 1
	JSR	STRTONUM
	CMP.I	FALSE
	BEQ	_SHELL_KILL_FUNC_FAIL
	LDA.Z	VR11
	STA.Z	VR4
	LDA.I	BC_KILL
	BRK
>_SHELL_KILL_FUNC_FAIL
	JMP	_SHELL_LOOP

>_SHELL_SYS_FUNC
	; who owns file perms
	; print the entire page map
	; print the entire page table

	LDA	_SHELL_SYS_OUT1
	STA.Z	VR0
	LDA	_SHELL_SYS_OUT1 1
	STA.Z	VR0 1
	JSR	PRINTL
	STZ.Z	VR3	; total active procs
	STZ.Z	VR3 1	; total pages in use
	LDX.I 0
>_SHELL_SYS_FUNC_DEFAULT_LOOP
	LDA.X	PROC_STATE
	CMP.I	PROC_STATE_NULL
	BNE	_SHELL_SYS_FUNC_DEFAULT_LOOP_GOOD
	JMP	_SHELL_SYS_FUNC_DEFAULT_LOOP_SKIP
>_SHELL_SYS_FUNC_DEFAULT_LOOP_GOOD
	INC.Z	VR3
	; print this process
	TXA		; print process ID
	JSR	PRINTH
	LDA.I	ASCII_SPACE
	JSR	PRINTC
	JSR	PRINTC
	TXA			; print process name
	ASL
	ASL
	ASL
	ASL
	STA.Z	VR0
	LDA.I	PROC_NAME > 8
	ADC.I	0
	STA.Z	VR0 1
	JSR	PRINTS
	JSR	STRLEN
	EOR.I	0XFF
	INC
	CLC
	ADC.I	17
	; A has spaces left to print
>_SHELL_SYS_FUNC_SPACE_LOOP
	PHA
	LDA.I	ASCII_SPACE
	JSR	PRINTC
	PLA
	DEC
	BNE	_SHELL_SYS_FUNC_SPACE_LOOP
	; print state
	LDA.X	PROC_STATE
	JSR	PRINTH
	LDA.I	ASCII_SPACE
	JSR	PRINTC
	JSR	PRINTC
	JSR	PRINTC
	JSR	PRINTC
	; print offset
	TXA
	ASL
	TAX
	LDA.X	PROC_PTROFF 1
	JSR	PRINTH
	LDA.X	PROC_PTROFF
	JSR	PRINTH
	LDA.I	ASCII_SPACE
	JSR	PRINTC
	JSR	PRINTC
	JSR	PRINTC
	TXA
	LSR
	TAX
	; print stack size
	LDA.I	0XFF
	SEC
	SBC.X	PROC_S
	JSR	PRINTH
	LDA.I	ASCII_SPACE
	JSR	PRINTC
	JSR	PRINTC
	JSR	PRINTC
	JSR	PRINTC
	; print pages
	LDY.I	0
	STZ.Z	VR2	; code pages
	STZ.Z	VR2 1	; data pages
>_SHELL_SYS_FUNC_PAGE_LOOP
	TXA
	CMP.Y	PAGE_TABLE_PROCID
	BNE	_SHELL_SYS_FUNC_PAGE_LOOP_SKIP
	INC.Z	VR3 1
	LDA.Y	PAGE_TABLE_HOME
	CMP.I	0X80
	BGE	_SHELL_SYS_FUNC_PAGE_LOOP_DATA
	INC.Z	VR2
	BRA	_SHELL_SYS_FUNC_PAGE_LOOP_SKIP
>_SHELL_SYS_FUNC_PAGE_LOOP_DATA
	INC.Z	VR2 1
>_SHELL_SYS_FUNC_PAGE_LOOP_SKIP
	INY
	CPY.I	PAGE_COUNT_TOTAL
	BNE	_SHELL_SYS_FUNC_PAGE_LOOP
	LDA.Z	VR2
	JSR	PRINTH
	LDA.I	ASCII_SPACE
	JSR	PRINTC
	JSR	PRINTC
	JSR	PRINTC
	JSR	PRINTC
	LDA.Z	VR2 1
	JSR	PRINTH
	LDA.I	ASCII_LF
	JSR	PRINTC
>_SHELL_SYS_FUNC_DEFAULT_LOOP_SKIP
	INX
	CPX.I	PROC_COUNT
	BEQ	_SHELL_SYS_FUNC_TOTALS
	JMP	_SHELL_SYS_FUNC_DEFAULT_LOOP
>_SHELL_SYS_FUNC_TOTALS
	LDA.Z	VR3
	STA.Z	VR4
	STZ.Z	VR4 1
	JSR	PRINTDU16
	LDA	_SHELL_SYS_OUT2
	STA.Z	VR0
	LDA	_SHELL_SYS_OUT2 1
	STA.Z	VR0 1
	JSR	PRINTL
	LDA.Z	VR3 1
	STA.Z	VR4
	STZ.Z	VR4 1
	JSR	PRINTDU16
	LDA	_SHELL_SYS_OUT3
	STA.Z	VR0
	LDA	_SHELL_SYS_OUT3 1
	STA.Z	VR0 1
	JSR	PRINTL
	; file perm owner
	LDA	IO_FILE_CLAIM
	JSR	PRINTH
	LDA	_SHELL_SYS_OUT4
	STA.Z	VR0
	LDA	_SHELL_SYS_OUT4 1
	STA.Z	VR0 1
	JSR	PRINTL
	; map
	LDA	_SHELL_SYS_OUT5
	STA.Z	VR0
	LDA	_SHELL_SYS_OUT5 1
	STA.Z	VR0 1
	JSR	PRINTL
	LDX.I	0
>_SHELL_SYS_FUNC_TABLE_LOOP
	TXA
	JSR	PAGE_MAP_FIND
	CMP.I	PAGE_COUNT_TOTAL
	BEQ	_SHELL_SYS_FUNC_TABLE_LOOP_SKIP
	PHA
	TXA
	JSR	PRINTH
	LDA.I	ASCII_SPACE
	JSR	PRINTC
	JSR	PRINTC
	JSR	PRINTC
	JSR	PRINTC
	JSR	PRINTC
	LDA.X	PAGE_TABLE_PROCID
	JSR	PRINTH
	LDA.I	ASCII_SPACE
	JSR	PRINTC
	JSR	PRINTC
	LDA.X	PAGE_TABLE_HOME
	JSR	PRINTH
	LDA.I	ASCII_SPACE
	JSR	PRINTC
	JSR	PRINTC
	JSR	PRINTC
	PLA
	JSR	PRINTH
	LDA.I	ASCII_LF
	JSR	PRINTC
>_SHELL_SYS_FUNC_TABLE_LOOP_SKIP
	INX
	CPX.I	PAGE_COUNT_TOTAL
	BNE	_SHELL_SYS_FUNC_TABLE_LOOP
	JMP	_SHELL_LOOP

>_SHELL_PEEK_FUNC
	JSR	_SHELL_NEXT_ARG
	CMP.I	0
	BNE	_SHELL_PEEK_FUNC_ARG
	JSR	_SHELL_MISSING_ARG_ERROR
	JMP	_SHELL_LOOP
>_SHELL_PEEK_FUNC_ARG
	LDA.Z	_SHELL_ARG_PTR
	STA.Z	VR0
	STZ.Z	VR0 1
	JSR	STRTONUM
	CMP.I	FALSE
	BEQ	_SHELL_PEEK_FUNC_FAIL
	LDA.ZP	VR11
	JSR	PRINTH
	LDA.I	ASCII_LF
	JSR	PRINTC
>_SHELL_PEEK_FUNC_FAIL
	JMP	_SHELL_LOOP

>_SHELL_POKE_FUNC
	JSR	_SHELL_NEXT_ARG
	CMP.I	0
	BNE	_SHELL_POKE_FUNC_ARG1
	JSR	_SHELL_MISSING_ARG_ERROR
	JMP	_SHELL_LOOP
>_SHELL_POKE_FUNC_ARG1
	LDA.Z	_SHELL_ARG_PTR
	STA.Z	VR0
	STZ.Z	VR0 1
	JSR	STRTONUM
	CMP.I	FALSE
	BEQ	_SHELL_POKE_FUNC_FAIL
	LDA.Z	VR11
	PHA
	LDA.Z	VR11 1
	PHA
	JSR	_SHELL_NEXT_ARG
	CMP.I	0
	BNE	_SHELL_POKE_FUNC_ARG2
	JSR	_SHELL_MISSING_ARG_ERROR
	JMP	_SHELL_LOOP
>_SHELL_POKE_FUNC_ARG2
	LDA.Z	_SHELL_ARG_PTR
	STA.Z	VR0
	STZ.Z	VR0 1
	JSR	STRTONUM
	CMP.I	FALSE
	BEQ	_SHELL_POKE_FUNC_FAIL
	PLA
	STA.Z	VR8 1
	PLA
	STA.Z	VR8
	LDA.Z	VR11
	STA.ZP	VR8
>_SHELL_POKE_FUNC_FAIL
	JMP	_SHELL_LOOP

;==================================================

; utility functions

;==================================================

; prints the missing arg error string
>_SHELL_MISSING_ARG_ERROR
	PHA					; store A
	LDA	_SHELL_MISSING_ARG_STR		; load missing arg string
	STA.Z	VR0
	LDA	_SHELL_MISSING_ARG_STR 1
	STA.Z	VR0 1
	JSR	PRINTL				; print
	PLA					; restore A
	RTS					; return

;==================================================

; gets the next argument and updates arg vars
; A = 0 if no new argument
; A = not 0 if new argument found
>_SHELL_NEXT_ARG
	PHY					; store Y
	LDA.Z	VR0				; store VR0
	PHA
	LDA.Z	VR0 1
	PHA
	LDA.Z	_SHELL_ARG_PTR			; load argument pointer
	STA.Z	VR0				; store in VR0
	STZ.Z	VR0 1
	LDY.Z	_SHELL_ARG_LEN			; load current argument length into Y
	LDA.Z	_SHELL_ARG_END			; load previously used word end character
	STA.ZPY	VR0				; restore word end character
	TYA					; move argument length to A
	CLC					; CLC for ADC
	ADC.Z	_SHELL_ARG_PTR			; add argument length to argument pointer value to get pointer to after argument
	STA.Z	VR0				; store in VR0
	STZ.Z	VR0 1
	JSR	STRLEAD				; trim leading whitespace
	LDA.Z	VR11				; load new pointer value to trimmed string
	STA.Z	_SHELL_ARG_PTR			; store trimmed string as new argument pointer
	STA.Z	VR0				; also set VR0 as this trimmed string pointer
	JSR	STRWORDLEN			; get length of next argument
	LDA.Z	VR11				; store length in argument length var
	STA.Z	_SHELL_ARG_LEN
	TAY					; move new argument length to Y
	LDA.ZPY	VR0				; load word end character of new argument
	STA.Z	_SHELL_ARG_END			; store in argument end var
	LDA.I	ASCII_NUL			; load nul char value
	STA.ZPY	VR0				; set word end of new argument to nul char
	PLA					; restore VR0
	STA.Z	VR0 1
	PLA
	STA.Z	VR0
	PLY					; restore Y
	LDA.Z	_SHELL_ARG_LEN			; load new argument length value to indicate if new argument found
	RTS					; return

>SHELL_END
