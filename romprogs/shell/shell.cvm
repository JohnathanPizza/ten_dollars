=_SHELL_ARG_PTR		0 ; 1
=_SHELL_ARG_LEN		1 ; 1
=_SHELL_TOT_LEN		2 ; 1
=_SHELL_INPUT_BUF	0X10 ; 0x40
=_SHELL_INPUT_BUF_LEN	0X40

>SHELL_START

	; get the process pointer offset to adjust strings
	LDA.I	BC_PTROFF					; interrupt to get offset
	BRK
	LDA.Z	VR11						; move offset to VR5 for adjust func
	STA.Z	VR5
	LDA.Z	VR11 1
	STA.Z	VR5 1
	LDA.I	_SHELL_PTR_ARRAY_END - _SHELL_PTR_ARRAY / 2	; load length of pointer array to adjust
	STA.Z	VR4
	LDA.I	_SHELL_PTR_ARRAY_END - _SHELL_PTR_ARRAY / 2 > 8
	STA.Z	VR4 1
	CLC							; add offset to pointer to array of string pointers to adjust
	LDA.I	_SHELL_PTR_ARRAY
	ADC.Z	VR5
	STA.Z	VR0
	LDA.I	_SHELL_PTR_ARRAY > 8
	ADC.Z	VR5 1
	STA.Z	VR0 1
	JSR	PROGRAM_POINTER_ADJUST				; adjust all string pointers

>_SHELL_LOOP

	JSR	_SHELL_PRINT_HEADER				; print input header

	JSR	_SHELL_GET_INPUT
	JSR	_SHELL_NEXT_ARG
	CMP.I	FALSE
	BEQ	_SHELL_LOOP

	LDA.Z	_SHELL_ARG_PTR
	STA.Z	VR1
	STZ.Z	VR1 1
	LDA.Z	_SHELL_ARG_LEN
	STA.Z	VR4
	LDX.I	0
>_SHELL_SEARCH_LOOP
	LDA.X	_SHELL_COMMAND_STR_PTR_ARRAY
	STA.Z	VR0
	LDA.X	_SHELL_COMMAND_STR_PTR_ARRAY 1
	STA.Z	VR0 1
	JSR	STRLEN
	CMP.Z	VR4
	BNE	_SHELL_SEARCH_LOOP_SKIP
	JSR	STRNCMP
	CMP.I	0
	BNE	_SHELL_SEARCH_LOOP_SKIP
	JMP.XP	_SHELL_FUNC_ARRAY
>_SHELL_SEARCH_LOOP_SKIP
	INX
	INX
	CPX.I	_SHELL_COMMAND_STR_PTR_ARRAY_END - _SHELL_COMMAND_STR_PTR_ARRAY
	BNE	_SHELL_SEARCH_LOOP

	LDA.I	ASCII_QUOTE
	JSR	PRINTC
	LDA.Z	_SHELL_ARG_PTR
	STA.Z	VR0
	STZ.Z	VR0 1
	LDY.Z	_SHELL_ARG_LEN
	LDA.I	ASCII_NUL
	STA.ZPY	VR0
	JSR	PRINTS
	LDA.I	ASCII_QUOTE
	JSR	PRINTC
	LDA	_SHELL_STR_PTR_ARRAY _SHELL_COMMAND_ERROR_STR_ID
	STA.Z	VR0
	LDA	_SHELL_STR_PTR_ARRAY _SHELL_COMMAND_ERROR_STR_ID 1
	STA.Z	VR0 1
	JSR	PRINTL
	JMP	_SHELL_LOOP

; command strings

>_SHELL_RUN_STR
"run\0
>_SHELL_RUND_STR
"rund\0
>_SHELL_EXIT_STR
"exit\0
>_SHELL_CF_STR
"cf\0
>_SHELL_KILL_STR
"kill\0
>_SHELL_SYS_STR
"sys\0
>_SHELL_ME_STR
"me\0
>_SHELL_PEEK_STR
"peek\0
>_SHELL_POKE_STR
"poke\0

; other strings

>_SHELL_MISSING_ARG_STR
"Missing argument(s)\0

>_SHELL_COMMAND_ERROR_STR
" is not a command\0

>_SHELL_HEADER_STR
"(shell) #\0

>_SHELL_SYS_OUT1 ; header string for processes
"PID NAME             STATE OFFSET STACK CODE# DATA#\0
;##12################1##1234####123##1234##1234##\n
>_SHELL_SYS_OUT2
"/32 processes active\0
>_SHELL_SYS_OUT3
"/240 pages active\0
>_SHELL_SYS_OUT4
" owns file permissions\0
>_SHELL_SYS_OUT5
"PAGEID PID HOME MAP\0 ; header for page information
;##12345##12##123\n

>_SHELL_PTR_ARRAY
>_SHELL_COMMAND_STR_PTR_ARRAY

$_SHELL_RUN_STR
$_SHELL_RUND_STR
$_SHELL_EXIT_STR
$_SHELL_CF_STR
$_SHELL_KILL_STR
$_SHELL_SYS_STR
$_SHELL_ME_STR
$_SHELL_PEEK_STR
$_SHELL_POKE_STR

>_SHELL_COMMAND_STR_PTR_ARRAY_END
>_SHELL_STR_PTR_ARRAY

$_SHELL_MISSING_ARG_STR
$_SHELL_COMMAND_ERROR_STR
$_SHELL_HEADER_STR
$_SHELL_SYS_OUT1
$_SHELL_SYS_OUT2
$_SHELL_SYS_OUT3
$_SHELL_SYS_OUT4
$_SHELL_SYS_OUT5

>_SHELL_PTR_ARRAY_END

; string IDs for other strings

=_SHELL_MISSING_ARG_STR_ID	0
=_SHELL_COMMAND_ERROR_STR_ID	2
=_SHELL_HEADER_STR_ID		4
=_SHELL_SYS_OUT1_ID		6
=_SHELL_SYS_OUT2_ID		8
=_SHELL_SYS_OUT3_ID		10
=_SHELL_SYS_OUT4_ID		12
=_SHELL_SYS_OUT5_ID		14

; function pointer array for command functions
; parallel to command strings array

>_SHELL_FUNC_ARRAY
$_SHELL_RUN_FUNC
$_SHELL_RUND_FUNC
$_SHELL_EXIT_FUNC
$_SHELL_CF_FUNC
$_SHELL_KILL_FUNC
$_SHELL_SYS_FUNC
$_SHELL_ME_FUNC
$_SHELL_PEEK_FUNC
$_SHELL_POKE_FUNC

; utility functions

; prints the missing arg error string
>_SHELL_MISSING_ARG_ERROR
	PHA							; store A
	LDA	_SHELL_STR_PTR_ARRAY _SHELL_MISSING_ARG_STR_ID	; load missing arg string
	STA.Z	VR0
	LDA	_SHELL_STR_PTR_ARRAY _SHELL_MISSING_ARG_STR_ID 1
	STA.Z	VR0 1
	JSR	PRINTL						; print
	PLA							; restore A
	RTS							; return

; gets new user input in the input buffer and resets arg vars
>_SHELL_GET_INPUT
	PHA				; store A
	LDA.Z	VR0			; save VR0
	PHA
	LDA.Z	VR0 1
	PHA
	LDA.Z	VR4			; save VR4/1
	PHA
	LDA.I	_SHELL_INPUT_BUF	; load pointer to input buffer
	STA.Z	_SHELL_ARG_PTR		; reset arg pointer
	STZ.Z	_SHELL_ARG_LEN		; reset arg length
	STA.Z	VR0			; set read buffer to input buffer
	STZ.Z	VR0 1
	LDA.I	_SHELL_INPUT_BUF_LEN	; load input buffer size
	STA.Z	VR4
	LDA.I	BC_READ			; load read code
	BRK				; get input
	JSR	PRINTL			; reflect input
	JSR	PRINT_WAIT		; wait
	JSR	STRLEN			; get input length
	STA.Z	_SHELL_TOT_LEN		; update total length
	PLA				; restore VR4/1
	STA.Z	VR4
	PLA				; restore VR0
	STA.Z	VR0 1
	PLA
	STA.Z	VR0
	PLA				; return A
	RTS				; return

; gets the next argument and updates arg vars
; returns in A TRUE or FALSE if there is or isnt another arg
>_SHELL_NEXT_ARG
	LDA.Z	_SHELL_ARG_PTR		; load arg pointer in VR10
	STA.Z	VR10
	STZ.Z	VR10 1
	LDA.Z	_SHELL_ARG_LEN		; add current arg length to set pointer to one after end of last arg
	STA.Z	VR11
	JSR	PROGRAM_GET_ARG		; get next arg
	PHA				; store result
	LDA.Z	VR10			; update arg pointer
	STA.Z	_SHELL_ARG_PTR
	LDA.Z	VR11			; update arg length
	STA.Z	_SHELL_ARG_LEN
	PLA				; restore result
	RTS				; return

; conditionally restores the truncated byte of args
>_SHELL_ARG_RESTORE
	PHA				; store A
	LDA.Z	VR0			; store VR0
	PHA
	LDA.Z	VR0 1
	PHA
	LDA.I	_SHELL_INPUT_BUF	; load pointer to input buf in VR0
	STA.Z	VR0
	STZ.Z	VR0 1
	JSR	STRLEN			; get length of input buffer
	CMP.Z	_SHELL_TOT_LEN		; compare to the length of input when first entered by user
	BEQ	_SHELL_ARG_RESTORE_SAME	; if the same, then any truncated byte shouldnt be restored as it is acting as the true buffer end
	PHY				; store Y
	LDY.Z	_SHELL_ARG_LEN		; load current arg length
	LDA.Z	_SHELL_ARG_PTR		; load current arg pointer in VR0
	STA.Z	VR0
	STZ.Z	VR0 1
	LDA.I	ASCII_SPACE		; set truncated byte back to non-delimiting whitespace character
	STA.ZPY	VR0
	PLY				; restore Y
>_SHELL_ARG_RESTORE_SAME
	PLA				; restore VR0
	STA.Z	VR0 1
	PLA
	STA.Z	VR0
	PLA				; restore A
	RTS				; return

;==================================================

>_SHELL_RUN_FUNC
	JSR	_SHELL_NEXT_ARG
	CMP.I	TRUE
	BEQ	_SHELL_RUN_FUNC_ARG
	JSR	_SHELL_MISSING_ARG_ERROR
	JMP	_SHELL_LOOP
>_SHELL_RUN_FUNC_ARG
	LDA.Z	_SHELL_ARG_PTR					; load pointer to name arg
	STA.Z	VR0						; set in VR0 for rom name finder
	STZ.Z	VR0 1
	LDA.I	ASCII_NUL					; truncate arg
	LDY.Z	_SHELL_ARG_LEN
	STA.ZPY	VR0
	JSR	ROM_PROGRAM_GET
	CMP.I	0XFF
	BEQ	_SHELL_RUN_FUNC_FAIL
	STA.Z	VR4
	LDA.I	BC_SPAWN_ROM
	BRK
	LDA.Z	VR11
	STA.Z	VR4
	LDA.I	BC_FOCUS_CHANGE
	BRK
	LDA.I	BC_WAIT_FOCUS
	BRK
>_SHELL_RUN_FUNC_FAIL
	JMP	_SHELL_LOOP

>_SHELL_RUND_FUNC
	JSR	_SHELL_NEXT_ARG
	CMP.I	TRUE
	BEQ	_SHELL_RUND_FUNC_ARG
	JSR	_SHELL_MISSING_ARG_ERROR
	JMP	_SHELL_LOOP
>_SHELL_RUND_FUNC_ARG
	LDA.I	BC_FILE_CLAIM
	BRK
	LDA.Z	VR11
	BEQ	_SHELL_RUND_FUNC_FAIL
	
	LDA.Z	_SHELL_ARG_PTR					; load pointer to name arg
	STA.Z	VR0						; set in VR0 for file open
	STZ.Z	VR0 1
	LDA.I	ASCII_NUL					; truncate arg
	LDY.Z	_SHELL_ARG_LEN
	STA.ZPY	VR0

	LDA.I	FILE_OP_OPEN_A					; *change to find and pass file id?
	STA.Z	VR6
	LDA.I	BC_FILE_OP
	BRK
	LDA.Z	VR11
	BNE	_SHELL_RUND_FUNC_FAIL

	LDA.I	BC_SPAWN_DISK
	BRK
	LDA.Z	VR11
	STA.Z	VR4
	LDA.I	BC_FILE_RELEASE
	BRK
	LDA.I	BC_FOCUS_CHANGE
	BRK
	LDA.I	BC_WAIT_FOCUS
	BRK
>_SHELL_RUND_FUNC_FAIL
	JMP	_SHELL_LOOP

>_SHELL_EXIT_FUNC
	LDA.I	BC_EXIT
	BRK

>_SHELL_CF_FUNC
	JSR	_SHELL_NEXT_ARG
	CMP.I	TRUE
	BEQ	_SHELL_CF_FUNC_ARG
	JSR	_SHELL_MISSING_ARG_ERROR
	JMP	_SHELL_LOOP
>_SHELL_CF_FUNC_ARG
	LDA.Z	_SHELL_ARG_PTR
	STA.Z	VR0
	STZ.Z	VR0 1
	LDA.I	ASCII_NUL
	LDY.Z	_SHELL_ARG_LEN
	STA.ZPY	VR0
	JSR	STRTONUM
	CMP.I	FALSE
	BEQ	_SHELL_CF_FUNC_FAIL
	LDA.Z	VR11
	STA.Z	VR4
	LDA.I	BC_FOCUS_CHANGE
	BRK
	LDA.I	BC_WAIT_FOCUS
	BRK
>_SHELL_CF_FUNC_FAIL
	JMP	_SHELL_LOOP

>_SHELL_ME_FUNC
	LDA	PROC_ACTIVE_ID
	JSR	PRINTH
	LDA.I	ASCII_LF
	JSR	PRINTC
	JMP	_SHELL_LOOP

>_SHELL_KILL_FUNC
	; dangerous
	JSR	_SHELL_NEXT_ARG
	CMP.I	TRUE
	BEQ	_SHELL_KILL_FUNC_ARG
	JSR	_SHELL_MISSING_ARG_ERROR
	JMP	_SHELL_LOOP
>_SHELL_KILL_FUNC_ARG
	LDA.Z	_SHELL_ARG_PTR
	STA.Z	VR0
	STZ.Z	VR0 1
	LDA.I	ASCII_NUL
	LDY.Z	_SHELL_ARG_LEN
	STA.ZPY	VR0
	JSR	STRTONUM
	CMP.I	FALSE
	BEQ	_SHELL_KILL_FUNC_FAIL
	LDA.Z	VR11
	STA.Z	VR4
	LDA.I	BC_KILL
	BRK
>_SHELL_KILL_FUNC_FAIL
	JMP	_SHELL_LOOP

; print "(shell) #" line
>_SHELL_PRINT_HEADER
	PHA				; store A
	LDA	_SHELL_STR_PTR_ARRAY _SHELL_HEADER_STR_ID	; print header string
	STA.Z	VR0
	LDA	_SHELL_STR_PTR_ARRAY _SHELL_HEADER_STR_ID 1
	STA.Z	VR0 1
	JSR	PRINTL
	PLA				; restore A
	RTS				; return

>_SHELL_SYS_FUNC
	; who owns file perms
	; print the entire page map
	; print the entire page table

	LDA	_SHELL_STR_PTR_ARRAY _SHELL_SYS_OUT1_ID
	STA.Z	VR0
	LDA	_SHELL_STR_PTR_ARRAY _SHELL_SYS_OUT1_ID 1
	STA.Z	VR0 1
	JSR	PRINTL
	STZ.Z	VR3	; total active procs
	STZ.Z	VR3 1	; total pages in use
	LDX.I 0
>_SHELL_SYS_FUNC_DEFAULT_LOOP
	LDA.X	PROC_STATE
	CMP.I	PROC_STATE_NULL
	BNE	_SHELL_SYS_FUNC_DEFAULT_LOOP_GOOD
	JMP	_SHELL_SYS_FUNC_DEFAULT_LOOP_SKIP
>_SHELL_SYS_FUNC_DEFAULT_LOOP_GOOD
	INC.Z	VR3
	; print this process
	TXA		; print process ID
	JSR	PRINTH
	LDA.I	ASCII_SPACE
	JSR	PRINTC
	JSR	PRINTC
	TXA			; print process name
	ASL
	ASL
	ASL
	ASL
	STA.Z	VR0
	LDA.I	PROC_NAME > 8
	ADC.I	0
	STA.Z	VR0 1
	JSR	PRINTS
	JSR	STRLEN
	EOR.I	0XFF
	INC
	CLC
	ADC.I	17
	; A has spaces left to print
>_SHELL_SYS_FUNC_SPACE_LOOP
	PHA
	LDA.I	ASCII_SPACE
	JSR	PRINTC
	PLA
	DEC
	BNE	_SHELL_SYS_FUNC_SPACE_LOOP
	; print state
	LDA.X	PROC_STATE
	JSR	PRINTH
	LDA.I	ASCII_SPACE
	JSR	PRINTC
	JSR	PRINTC
	JSR	PRINTC
	JSR	PRINTC
	; print offset
	TXA
	ASL
	TAX
	LDA.X	PROC_PTROFF 1
	JSR	PRINTH
	LDA.X	PROC_PTROFF
	JSR	PRINTH
	LDA.I	ASCII_SPACE
	JSR	PRINTC
	JSR	PRINTC
	JSR	PRINTC
	TXA
	LSR
	TAX
	; print stack size
	LDA.I	0XFF
	SEC
	SBC.X	PROC_S
	JSR	PRINTH
	LDA.I	ASCII_SPACE
	JSR	PRINTC
	JSR	PRINTC
	JSR	PRINTC
	JSR	PRINTC
	; print pages
	LDY.I	0
	STZ.Z	VR2	; code pages
	STZ.Z	VR2 1	; data pages
>_SHELL_SYS_FUNC_PAGE_LOOP
	TXA
	CMP.Y	PAGE_TABLE_PROCID
	BNE	_SHELL_SYS_FUNC_PAGE_LOOP_SKIP
	INC.Z	VR3 1
	LDA.Y	PAGE_TABLE_HOME
	CMP.I	0X80
	BGE	_SHELL_SYS_FUNC_PAGE_LOOP_DATA
	INC.Z	VR2
	BRA	_SHELL_SYS_FUNC_PAGE_LOOP_SKIP
>_SHELL_SYS_FUNC_PAGE_LOOP_DATA
	INC.Z	VR2 1
>_SHELL_SYS_FUNC_PAGE_LOOP_SKIP
	INY
	CPY.I	PAGE_COUNT_TOTAL
	BNE	_SHELL_SYS_FUNC_PAGE_LOOP
	LDA.Z	VR2
	JSR	PRINTH
	LDA.I	ASCII_SPACE
	JSR	PRINTC
	JSR	PRINTC
	JSR	PRINTC
	JSR	PRINTC
	LDA.Z	VR2 1
	JSR	PRINTH
	LDA.I	ASCII_LF
	JSR	PRINTC
>_SHELL_SYS_FUNC_DEFAULT_LOOP_SKIP
	INX
	CPX.I	PROC_COUNT
	BEQ	_SHELL_SYS_FUNC_TOTALS
	JMP	_SHELL_SYS_FUNC_DEFAULT_LOOP
>_SHELL_SYS_FUNC_TOTALS
	LDA.Z	VR3
	STA.Z	VR4
	STZ.Z	VR4 1
	JSR	PRINTDU16
	LDA	_SHELL_STR_PTR_ARRAY _SHELL_SYS_OUT2_ID
	STA.Z	VR0
	LDA	_SHELL_STR_PTR_ARRAY _SHELL_SYS_OUT2_ID 1
	STA.Z	VR0 1
	JSR	PRINTL
	LDA.Z	VR3 1
	STA.Z	VR4
	STZ.Z	VR4 1
	JSR	PRINTDU16
	LDA	_SHELL_STR_PTR_ARRAY _SHELL_SYS_OUT3_ID
	STA.Z	VR0
	LDA	_SHELL_STR_PTR_ARRAY _SHELL_SYS_OUT3_ID 1
	STA.Z	VR0 1
	JSR	PRINTL
	; file perm owner
	LDA	IO_FILE_CLAIM
	JSR	PRINTH
	LDA	_SHELL_STR_PTR_ARRAY _SHELL_SYS_OUT4_ID
	STA.Z	VR0
	LDA	_SHELL_STR_PTR_ARRAY _SHELL_SYS_OUT4_ID 1
	STA.Z	VR0 1
	JSR	PRINTL
	; map
	LDA	_SHELL_STR_PTR_ARRAY _SHELL_SYS_OUT5_ID
	STA.Z	VR0
	LDA	_SHELL_STR_PTR_ARRAY _SHELL_SYS_OUT5_ID 1
	STA.Z	VR0 1
	JSR	PRINTL
	LDX.I	0
>_SHELL_SYS_FUNC_TABLE_LOOP
	TXA
	JSR	PAGE_MAP_FIND
	CMP.I	PAGE_COUNT_TOTAL
	BEQ	_SHELL_SYS_FUNC_TABLE_LOOP_SKIP
	PHA
	TXA
	JSR	PRINTH
	LDA.I	ASCII_SPACE
	JSR	PRINTC
	JSR	PRINTC
	JSR	PRINTC
	JSR	PRINTC
	JSR	PRINTC
	LDA.X	PAGE_TABLE_PROCID
	JSR	PRINTH
	LDA.I	ASCII_SPACE
	JSR	PRINTC
	JSR	PRINTC
	LDA.X	PAGE_TABLE_HOME
	JSR	PRINTH
	LDA.I	ASCII_SPACE
	JSR	PRINTC
	JSR	PRINTC
	JSR	PRINTC
	PLA
	JSR	PRINTH
	LDA.I	ASCII_LF
	JSR	PRINTC
>_SHELL_SYS_FUNC_TABLE_LOOP_SKIP
	INX
	CPX.I	PAGE_COUNT_TOTAL
	BNE	_SHELL_SYS_FUNC_TABLE_LOOP
	JMP	_SHELL_LOOP

>_SHELL_PEEK_FUNC
	JSR	_SHELL_NEXT_ARG
	CMP.I	TRUE
	BEQ	_SHELL_PEEK_FUNC_ARG
	JSR	_SHELL_MISSING_ARG_ERROR
	JMP	_SHELL_LOOP
>_SHELL_PEEK_FUNC_ARG
	LDA.Z	_SHELL_ARG_PTR
	STA.Z	VR0
	STZ.Z	VR0 1
	LDA.I	ASCII_NUL
	LDY.Z	_SHELL_ARG_LEN
	STA.ZPY	VR0
	JSR	STRTONUM
	CMP.I	FALSE
	BEQ	_SHELL_PEEK_FUNC_FAIL
	LDA.ZP	VR11
	JSR	PRINTH
	LDA.I	ASCII_LF
	JSR	PRINTC
>_SHELL_PEEK_FUNC_FAIL
	JMP	_SHELL_LOOP

>_SHELL_POKE_FUNC
	JSR	_SHELL_NEXT_ARG
	CMP.I	TRUE
	BEQ	_SHELL_POKE_FUNC_ARG1
	JSR	_SHELL_MISSING_ARG_ERROR
	JMP	_SHELL_LOOP
>_SHELL_POKE_FUNC_ARG1
	LDA.Z	_SHELL_ARG_PTR
	STA.Z	VR0
	STZ.Z	VR0 1
	LDA.I	ASCII_NUL
	LDY.Z	_SHELL_ARG_LEN
	STA.ZPY	VR0
	JSR	STRTONUM
	CMP.I	FALSE
	BEQ	_SHELL_POKE_FUNC_FAIL
	LDA.Z	VR11
	PHA
	LDA.Z	VR11 1
	PHA
	JSR	_SHELL_ARG_RESTORE
	JSR	_SHELL_NEXT_ARG
	CMP.I	TRUE
	BEQ	_SHELL_POKE_FUNC_ARG2
	JSR	_SHELL_MISSING_ARG_ERROR
	JMP	_SHELL_LOOP
>_SHELL_POKE_FUNC_ARG2
	LDA.Z	_SHELL_ARG_PTR
	STA.Z	VR0
	STZ.Z	VR0 1
	LDA.I	ASCII_NUL
	LDY.Z	_SHELL_ARG_LEN
	STA.ZPY	VR0
	JSR	STRTONUM
	CMP.I	FALSE
	BEQ	_SHELL_POKE_FUNC_FAIL
	PLA
	STA.Z	VR8 1
	PLA
	STA.Z	VR8
	LDA.Z	VR11
	STA.ZP	VR8
>_SHELL_POKE_FUNC_FAIL
	JMP	_SHELL_LOOP

>SHELL_END
