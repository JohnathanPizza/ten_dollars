=SHELL_PTROFFL		0
=SHELL_PTROFFH		1

=SHELL_INPUT_BUF	0X40
=SHELL_INPUT_BUF_SIZE	0X40

>SHELL_START

	LDA.I	BC_PTROFF			; get ptr offset
	BRK
	LDA.Z	VR11				; store ptr offset low in ptroffl
	STA.Z	SHELL_PTROFFL
	LDA.Z	VR11 1				; ptr offset high in ptroffh
	STA.Z	SHELL_PTROFFH
	JSR	SHELL_ADJPTRS			; adjust pointers

>_SHELL_MAIN_LOOP

	LDA.I	BC_WRITE_CLAIM			; get a write claim for printing the shell ready message
	BRK
	LDA	SHELL_PTRS SHELL_STR_READY_PID 0	; load string pointer
	STA.Z	VR0
	LDA	SHELL_PTRS SHELL_STR_READY_PID 1
	STA.Z	VR0 1
	JSR	PRINTL				; print
	LDA.I	BC_WRITE_RELEASE		; release write claim while getting input
	BRK

	JSR	SHELL_GET_INPUT			; grab some input

	LDA.I	BC_WRITE_CLAIM			; get write claim to print the input
	BRK
	LDA.I	ASCII_PERCENT			; print %
	JSR	PRINTC
	LDA.I	SHELL_INPUT_BUF			; load input buffer pointer
	STA.Z	VR0
	STZ.Z	VR0 1
	JSR	PRINTL				; print input buffer
	LDA.I	BC_WRITE_RELEASE		; release write claim
	BRK

	LDX.I	0				; set index to 0
>_SHELL_COMMAND_PTR_LOOP
	LDA.X	SHELL_COMMAND_STR_PTRS 0	; load low part of pointer to string
	STA.Z	VR1				; store
	LDA.X	SHELL_COMMAND_STR_PTRS 1	; load high part of pointer to string
	STA.Z	VR1 1				; store
	JSR	STRCMP				; compare strings
	CMP.I	0				; test if input buf equals command string
	BEQ	_SHELL_COMMAND_PTR_LOOP_FOUND	; run matching command
	INX					; inc index
	INX					; inc index again for ptr stride
	CPX.I	SHELL_COMMAND_STR_PTRS_END - SHELL_COMMAND_STR_PTRS	; test if done
	BNE	_SHELL_COMMAND_PTR_LOOP		; loop if not

	; no matching command string, print error message and try again
	LDA.I	BC_WRITE_CLAIM
	BRK
	LDA	SHELL_PTRS SHELL_STR_FAIL_PID 0	; load pointer to fail string
	STA.Z	VR0
	LDA	SHELL_PTRS SHELL_STR_FAIL_PID 1
	STA.Z	VR0 1
	JSR	PRINTL				; print
	LDA.I	BC_WRITE_RELEASE
	BRK
	JMP	_SHELL_MAIN_LOOP		; loop back up

>_SHELL_COMMAND_PTR_LOOP_FOUND

	JMP.XP	SHELL_COMMAND_FUNC_PTRS		; jump to the command function using X value from string search

	LDA.I	BC_EXIT
	BRK

;=====

>SHELL_PTRS

$SHELL_STR_READY
=SHELL_STR_READY_PID	0
$SHELL_STR_FAIL
=SHELL_STR_FAIL_PID	2
$SHELL_STR_RUN_FAIL
=SHELL_STR_RUN_FAIL_PID 4

>SHELL_COMMAND_STR_PTRS
$SHELL_COMMAND_STR_RUN
>SHELL_COMMAND_STR_PTRS_END

>SHELL_COMMAND_FUNC_PTRS
$SHELL_COMMAND_RUN

>SHELL_PTRS_END

;=====

>SHELL_STR_READY
"shell ready\0
>SHELL_STR_FAIL
"no command exists\0
>SHELL_STR_RUN_FAIL
"no program exists\0
>SHELL_COMMAND_STR_RUN
"run\0

;=====

>SHELL_ADJPTRS
	PHA				; store A
	PHX				; store X
	LDX.I	0			; set X to 0
>_SHELL_ADJPTRS_LOOP
	CLC				; clc for adc
	LDA.X	SHELL_PTRS		; load low value for pointer
	ADC.Z	SHELL_PTROFFL		; add ptroff low
	STA.X	SHELL_PTRS		; store back
	LDA.X	SHELL_PTRS 1		; load high value for pointer
	ADC.Z	SHELL_PTROFFH		; add ptroff high
	STA.X	SHELL_PTRS 1		; store back
	INX				; X += 1
	INX				; X += 2 for pointer stride
	CPX.I	SHELL_PTRS_END - SHELL_PTRS	; test if done
	BNE	_SHELL_ADJPTRS_LOOP	; loop if not
	PLX				; restore X
	PLA				; restore A
	RTS				; return

>SHELL_GET_INPUT
	PHA				; store A
	LDA.Z	VR0			; save VR0
	PHA
	LDA.Z	VR0 1
	PHA
	LDA.Z	VR4			; save VR4/1
	PHA
	LDA.I	SHELL_INPUT_BUF		; load pointer to input buffer
	STA.Z	VR0
	STZ.Z	VR0 1
	LDA.I	SHELL_INPUT_BUF_SIZE	; load input buffer size
	STA.Z	VR4
	LDA.I	BC_READ			; load read code
	BRK				; get input
	PLA				; restore VR4/1
	STA.Z	VR4
	PLA				; restore VR0
	STA.Z	VR0 1
	PLA
	STA.Z	VR0
	PLA				; return A
	RTS				; return

;=====

>SHELL_COMMAND_RUN
	JSR	SHELL_GET_INPUT
	LDA.I	SHELL_INPUT_BUF
	STA.Z	VR0
	STZ.Z	VR0 1
	LDA.I	BC_WRITE_CLAIM
	BRK
	JSR	PRINTL
	JSR	PRINT_WAIT
	LDA.I	BC_WRITE_RELEASE
	BRK
	JSR	ROM_PROGRAM_GET
	CMP.I	0XFF
	BEQ	_SHELL_COMMAND_RUN_FAIL
	STA.Z	VR4
	LDA.I	BC_SPAWN_ROM
	BRK
	LDA.Z	VR11
	STA.Z	VR4
	LDA.I	BC_FOCUS_CHANGE
	BRK
	LDA.I	BC_WAIT_FOCUS
	BRK
	JMP	_SHELL_MAIN_LOOP
>_SHELL_COMMAND_RUN_FAIL
	LDA.I	BC_WRITE_CLAIM
	BRK
	LDA	SHELL_PTRS SHELL_STR_RUN_FAIL_PID 0
	STA.Z	VR0
	LDA	SHELL_PTRS SHELL_STR_RUN_FAIL_PID 1
	STA.Z	VR0 1
	JSR	PRINTL
	LDA.I	BC_WRITE_RELEASE
	BRK
	JMP	_SHELL_MAIN_LOOP

>SHELL_END
