; go through
>SCHEDULER_SELECT
	PHA				; store A
	PHX				; store X
	STZ.Z	VR8			; set current high count to 0
	STZ.Z	VR11			; set current proc to proc 0
	LDX.I	0			; load proc idx to 0
>_SCHEDULER_SELECT_LOOP
	LDA.Z	VR8			; get the current high count
	CMP.X	PROC_SCHEDULE_COUNT	; if the current high count >= this proc count skip
	BGE	_SCHEDULER_SELECT_LOOP_CONT
	STX.Z	VR11			; else change highest proc
	LDA.X	PROC_SCHEDULE_COUNT	; get count
	STA.Z	VR8			; make new high count
>_SCHEDULER_SELECT_LOOP_CONT
	INX				; inc proc
	CPX.I	PROC_COUNT		; compare to num of procs
	BNE	_SCHEDULER_SELECT_LOOP	; loop
	PLX
	PLA
	RTS

; add schedule priority to each counter untill 255
>SCHEDULER_INCREMENT
	PHA
	PHX
	LDX.I	0
>_SCHEDULER_INCREMENT_LOOP
	LDA.X	PROC_SCHEDULE_COUNT
	CLC
	ADC.X	PROC_SCHEDULE_PRIORITY
	BCC	_SCHEDULER_INCREMENT_LOOP_CONT
	LDA.I	0XFF
>_SCHEDULER_INCREMENT_LOOP_CONT
	STA.X	PROC_SCHEDULE_COUNT
	INX
	CPX.I	PROC_COUNT
	BNE	_SCHEDULER_INCREMENT_LOOP
	PLX
	PLA
	RTS

; new idea:
; service cycle
; the os is essentially just picking out processes and 'serving' their needs for a bit
; a service cycle includes running the scheduler, picking a proc, running it, completeing its interrupts, then eventually suspending for some reason and put on hold
; then the os will start a new service cycle to store the last proc, pick another and go
